# 2025-11-01 æ˜æ—¥å·¥ä½œè®¡åˆ’

**æ—¥æœŸ**: 2025å¹´11æœˆ1æ—¥ï¼ˆå‘¨äº”ï¼‰  
**é¢„è®¡å·¥ä½œæ—¶é•¿**: 8-10å°æ—¶  
**æ ¸å¿ƒç›®æ ‡**: å®ŒæˆPhase 1ï¼Œå¯åŠ¨Phase 2æ ¸å¿ƒç©æ³•å¼€å‘

---

## ğŸ¯ æ€»ä½“ç›®æ ‡

### ä¸»è¦ç›®æ ‡
1. âœ… **å®ŒæˆPhase 1.6: iframeé€šä¿¡ç³»ç»Ÿ**ï¼ˆPhase 1çš„æœ€åä¸€å—æ‹¼å›¾ï¼‰
2. ğŸš€ **å¯åŠ¨Phase 2.1: å¡ç‰Œæˆ˜æ–—ç³»ç»Ÿ**ï¼ˆæ ¸å¿ƒç©æ³•çš„ç¬¬ä¸€æ­¥ï¼‰
3. ğŸ® **å®ç°åŸºç¡€çš„æ‰“ç‰ŒDemo**ï¼ˆå¯è§†åŒ–ï¼ŒéªŒè¯å¯è¡Œæ€§ï¼‰

### æˆåŠŸæ ‡å‡†
- [ ] iframeèƒ½æ­£å¸¸ä¸SillyTaverné€šä¿¡
- [ ] å¡ç‰ŒUIèƒ½æ­£ç¡®æ˜¾ç¤ºå’Œæ‹–æ‹½
- [ ] èƒ½å®Œæ•´è·‘é€šä¸€å±€ç®€å•çš„æ‰“ç‰Œæ¸¸æˆ
- [ ] å¯¹æ‰‹åˆ†æ•°æ¨¡æ‹Ÿå™¨æ­£å¸¸å·¥ä½œ

---

## ğŸ“‹ è¯¦ç»†ä»»åŠ¡æ¸…å•

### ä¸Šåˆ (9:00 - 12:00)ï¼šPhase 1.6 iframeé€šä¿¡ç³»ç»Ÿ âš¡

**é‡è¦æ€§**: ğŸ”´ **Phase 2çš„å¿…è¦å‰ç½®æ¡ä»¶**

#### ä»»åŠ¡1: åˆ›å»ºloaderè„šæœ¬ï¼ˆ2å°æ—¶ï¼‰

**æ–‡ä»¶**: `idolmaster_loader.html`

**å®ç°å†…å®¹**:
```html
<!DOCTYPE html>
<html>
<head>
  <title>å¶åƒå¤§å¸ˆé—ªè€€è‰²å½© Loader</title>
</head>
<body>
  <!-- iframeå®¹å™¨ -->
  <div id="game-container"></div>
  
  <script>
    let iframeWindow = null;
    let currentRequestId = null;
    
    // 1. åŠ è½½Vueåº”ç”¨iframe
    window.addEventListener('load', () => {
      const iframe = document.createElement('iframe');
      iframe.src = './dist/å¶åƒå¤§å¸ˆé—ªè€€è‰²å½©/index.html';
      iframe.width = '100%';
      iframe.height = '100%';
      iframe.style.border = 'none';
      document.getElementById('game-container').appendChild(iframe);
      
      iframe.onload = () => {
        iframeWindow = iframe.contentWindow;
        console.log('Vueåº”ç”¨åŠ è½½å®Œæˆ');
      };
    });
    
    // 2. ç›‘å¬Vueå‘æ¥çš„æ¶ˆæ¯
    window.addEventListener('message', (event) => {
      if (event.source === iframeWindow) {
        console.log('æ”¶åˆ°Vueæ¶ˆæ¯:', event.data);
        
        if (event.data.type === 'SEND_PROMPT') {
          handleSendPrompt(event.data.payload);
        } else if (event.data.type === 'SWITCH_CHARACTER') {
          handleSwitchCharacter(event.data.payload);
        }
      }
    });
    
    // 3. å¤„ç†å‘é€æç¤ºè¯
    function handleSendPrompt(payload) {
      const { full_prompt, bot_name, request_id } = payload;
      currentRequestId = request_id;
      
      // å¦‚æœæŒ‡å®šäº†Botï¼Œå…ˆåˆ‡æ¢è§’è‰²
      if (bot_name) {
        SillyTavern.Api.command(`/switchchar "${bot_name}"`);
      }
      
      // å‘é€å®Œæ•´æç¤ºè¯ï¼ˆVueå·²ç»ç»„è£…å¥½ï¼‰
      SillyTavern.Api.command(`/say "${full_prompt}"`, true);
    }
    
    // 4. æ‹¦æˆªAIå›å¤
    eventOn('chat:received', (message) => {
      if (iframeWindow && currentRequestId) {
        // å‘å›Vue
        iframeWindow.postMessage({
          type: 'AI_RESPONSE',
          payload: {
            text: message.message,
            request_id: currentRequestId
          }
        }, '*');
        
        // é™é»˜å¤„ç†ï¼ˆä¸æ˜¾ç¤ºåœ¨èŠå¤©æ°”æ³¡ï¼‰
        message.message = "";
        currentRequestId = null;
      }
    });
    
    // 5. é”™è¯¯å¤„ç†
    window.addEventListener('error', (event) => {
      if (iframeWindow) {
        iframeWindow.postMessage({
          type: 'ERROR',
          payload: { message: event.message }
        }, '*');
      }
    });
  </script>
</body>
</html>
```

**äº¤ä»˜æ ‡å‡†**:
- [x] æ–‡ä»¶åˆ›å»ºå®Œæˆ
- [x] èƒ½åŠ è½½Vueåº”ç”¨iframe
- [x] èƒ½æ¥æ”¶Vueçš„postMessage
- [x] èƒ½æ‹¦æˆªAIå›å¤

---

#### ä»»åŠ¡2: Vueç«¯é€šä¿¡æ¨¡å—ï¼ˆ1å°æ—¶ï¼‰

**æ–‡ä»¶**: `src/å¶åƒå¤§å¸ˆé—ªè€€è‰²å½©/communication.ts`

**å®ç°å†…å®¹**:
```typescript
/**
 * iframeé€šä¿¡æ¨¡å—
 * è´Ÿè´£Vueåº”ç”¨ä¸SillyTavernçš„åŒå‘é€šä¿¡
 */

// ==================== ç±»å‹å®šä¹‰ ====================

/**
 * Vue â†’ STçš„æ¶ˆæ¯ç±»å‹
 */
export type VueToSTMessage = 
  | {
      type: 'SEND_PROMPT';
      payload: {
        full_prompt: string;
        bot_name?: string;
        request_id?: string;
      };
    }
  | {
      type: 'SWITCH_CHARACTER';
      payload: {
        character_name: string;
      };
    };

/**
 * ST â†’ Vueçš„æ¶ˆæ¯ç±»å‹
 */
export type STToVueMessage =
  | {
      type: 'AI_RESPONSE';
      payload: {
        text: string;
        request_id?: string;
      };
    }
  | {
      type: 'ERROR';
      payload: {
        message: string;
      };
    };

// ==================== å‘é€å™¨ ====================

/**
 * å‘é€æ¶ˆæ¯åˆ°SillyTavern
 */
export function sendToSillyTavern(message: VueToSTMessage): void {
  if (window.parent === window) {
    console.warn('ä¸åœ¨iframeä¸­ï¼Œæ— æ³•å‘é€æ¶ˆæ¯');
    return;
  }
  
  console.log('å‘é€æ¶ˆæ¯åˆ°ST:', message);
  window.parent.postMessage(message, '*');
}

/**
 * å‘é€å®Œæ•´æç¤ºè¯åˆ°AI
 */
export function sendPromptToAI(options: {
  prompt: string;
  botName?: string;
  requestId?: string;
}): void {
  sendToSillyTavern({
    type: 'SEND_PROMPT',
    payload: {
      full_prompt: options.prompt,
      bot_name: options.botName,
      request_id: options.requestId
    }
  });
}

// ==================== æ¥æ”¶å™¨ ====================

/**
 * AIå›å¤å›è°ƒç±»å‹
 */
type AIResponseCallback = (response: {
  text: string;
  requestId?: string;
}) => void;

/**
 * é”™è¯¯å›è°ƒç±»å‹
 */
type ErrorCallback = (error: { message: string }) => void;

// å›è°ƒå­˜å‚¨
const callbacks = {
  aiResponse: [] as AIResponseCallback[],
  error: [] as ErrorCallback[]
};

/**
 * ç›‘å¬AIå›å¤
 */
export function onAIResponse(callback: AIResponseCallback): void {
  callbacks.aiResponse.push(callback);
}

/**
 * ç›‘å¬é”™è¯¯
 */
export function onError(callback: ErrorCallback): void {
  callbacks.error.push(callback);
}

/**
 * åˆå§‹åŒ–æ¶ˆæ¯ç›‘å¬å™¨
 */
export function initCommunication(): void {
  window.addEventListener('message', (event) => {
    // åªæ¥å—æ¥è‡ªçˆ¶çª—å£çš„æ¶ˆæ¯
    if (event.source !== window.parent) return;
    
    const message = event.data as STToVueMessage;
    console.log('æ”¶åˆ°STæ¶ˆæ¯:', message);
    
    if (message.type === 'AI_RESPONSE') {
      callbacks.aiResponse.forEach(cb => cb({
        text: message.payload.text,
        requestId: message.payload.request_id
      }));
    } else if (message.type === 'ERROR') {
      callbacks.error.forEach(cb => cb({
        message: message.payload.message
      }));
    }
  });
  
  console.log('é€šä¿¡æ¨¡å—å·²åˆå§‹åŒ–');
}

// ==================== ä¾¿æ·å‡½æ•° ====================

/**
 * å‘é€æç¤ºè¯å¹¶ç­‰å¾…AIå›å¤ï¼ˆPromiseåŒ…è£…ï¼‰
 */
export function requestAI(options: {
  prompt: string;
  botName?: string;
  timeout?: number;
}): Promise<string> {
  return new Promise((resolve, reject) => {
    const requestId = `req_${Date.now()}_${Math.random()}`;
    let timeoutId: number | null = null;
    
    // è®¾ç½®è¶…æ—¶
    if (options.timeout) {
      timeoutId = window.setTimeout(() => {
        reject(new Error('AIè¯·æ±‚è¶…æ—¶'));
      }, options.timeout);
    }
    
    // ç›‘å¬å›å¤ï¼ˆä¸€æ¬¡æ€§ï¼‰
    const handleResponse = (response: { text: string; requestId?: string }) => {
      if (response.requestId === requestId) {
        if (timeoutId) clearTimeout(timeoutId);
        resolve(response.text);
      }
    };
    
    onAIResponse(handleResponse);
    
    // å‘é€è¯·æ±‚
    sendPromptToAI({
      prompt: options.prompt,
      botName: options.botName,
      requestId
    });
  });
}
```

**äº¤ä»˜æ ‡å‡†**:
- [x] ç±»å‹å®šä¹‰å®Œæ•´
- [x] å‘é€å‡½æ•°å¯ç”¨
- [x] æ¥æ”¶ç›‘å¬å™¨å¯ç”¨
- [x] PromiseåŒ…è£…å¯ç”¨

---

#### ä»»åŠ¡3: é€šä¿¡æµ‹è¯•ï¼ˆ30åˆ†é’Ÿï¼‰

**æµ‹è¯•æ–‡ä»¶**: `src/å¶åƒå¤§å¸ˆé—ªè€€è‰²å½©/communication-test.ts`

```typescript
import { initCommunication, requestAI, onAIResponse, onError } from './communication';

// åœ¨app.vueçš„onMountedä¸­è°ƒç”¨
export async function testCommunication() {
  console.log('===== å¼€å§‹é€šä¿¡æµ‹è¯• =====');
  
  // åˆå§‹åŒ–
  initCommunication();
  
  // æµ‹è¯•1: ç®€å•æç¤ºè¯
  console.log('æµ‹è¯•1: å‘é€ç®€å•æç¤ºè¯');
  try {
    const response = await requestAI({
      prompt: 'è¯·è¯´"ä½ å¥½ï¼Œåˆ¶ä½œäººï¼"',
      timeout: 30000
    });
    console.log('âœ… AIå›å¤:', response);
  } catch (error) {
    console.error('âŒ æµ‹è¯•1å¤±è´¥:', error);
  }
  
  // æµ‹è¯•2: ä½¿ç”¨ç‰¹å®šBot
  console.log('æµ‹è¯•2: åˆ‡æ¢åˆ°ç‰¹å®šBot');
  try {
    const response = await requestAI({
      prompt: 'è¯·ä»‹ç»ä½ è‡ªå·±',
      botName: 'Card Generation Bot',
      timeout: 30000
    });
    console.log('âœ… Botå›å¤:', response);
  } catch (error) {
    console.error('âŒ æµ‹è¯•2å¤±è´¥:', error);
  }
  
  console.log('===== é€šä¿¡æµ‹è¯•å®Œæˆ =====');
}
```

**æµ‹è¯•æ¸…å•**:
- [ ] æµ‹è¯•1: ç®€å•æç¤ºè¯èƒ½æ”¶åˆ°å›å¤
- [ ] æµ‹è¯•2: åˆ‡æ¢Botèƒ½æ­£å¸¸å·¥ä½œ
- [ ] æµ‹è¯•3: è¶…æ—¶æœºåˆ¶æ­£å¸¸
- [ ] æµ‹è¯•4: é”™è¯¯å¤„ç†æ­£å¸¸

**äº¤ä»˜ç‰©**:
- âœ… `idolmaster_loader.html`ï¼ˆloaderè„šæœ¬ï¼‰
- âœ… `src/å¶åƒå¤§å¸ˆé—ªè€€è‰²å½©/communication.ts`ï¼ˆé€šä¿¡æ¨¡å—ï¼‰
- âœ… é€šä¿¡æµ‹è¯•é€šè¿‡æŠ¥å‘Š

---

### ä¸‹åˆ (14:00 - 18:00)ï¼šPhase 2.1 å¡ç‰Œæˆ˜æ–—ç³»ç»ŸUI ğŸ®

#### ä»»åŠ¡4: åˆ›å»ºæ–‡ä»¶ç»“æ„ï¼ˆ30åˆ†é’Ÿï¼‰

**åˆ›å»ºæ–‡ä»¶å¤¹**:
```
src/å¶åƒå¤§å¸ˆé—ªè€€è‰²å½©-cardgame/
â”œâ”€â”€ index.html          # æ‰“ç‰Œç³»ç»Ÿå…¥å£
â”œâ”€â”€ index.ts            # TypeScriptå…¥å£
â”œâ”€â”€ index.scss          # å…¨å±€æ ·å¼
â”œâ”€â”€ app.vue             # ä¸»ç•Œé¢ï¼ˆæˆ˜åœºï¼‰
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ Card.vue        # å•å¼ å¡ç‰Œç»„ä»¶
â”‚   â”œâ”€â”€ Hand.vue        # æ‰‹ç‰ŒåŒº
â”‚   â”œâ”€â”€ Field.vue       # åœºåœ°åŒºï¼ˆå·²æ‰“å‡ºçš„å¡ï¼‰
â”‚   â””â”€â”€ ScoreBoard.vue  # åˆ†æ•°æ¿
â”œâ”€â”€ types.ts            # ç±»å‹å®šä¹‰
â”œâ”€â”€ game-logic.ts       # æ¸¸æˆæ ¸å¿ƒé€»è¾‘
â””â”€â”€ rival-simulator.ts  # å¯¹æ‰‹æ¨¡æ‹Ÿå™¨
```

**index.html**:
```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>å¶åƒå¤§å¸ˆé—ªè€€è‰²å½© - å¡ç‰Œæˆ˜æ–—</title>
</head>
<body>
  <div id="app"></div>
  <script src="./index.ts"></script>
</body>
</html>
```

**index.ts**:
```typescript
import $ from 'jquery';
import { createApp } from 'vue';
import App from './app.vue';
import './index.scss';

$(() => {
  const app = createApp(App);
  app.mount('#app');
  toastr.success('å¡ç‰Œæˆ˜æ–—ç³»ç»ŸåŠ è½½å®Œæˆï¼');
});
```

---

#### ä»»åŠ¡5: å®šä¹‰æ•°æ®ç»“æ„ï¼ˆ30åˆ†é’Ÿï¼‰

**æ–‡ä»¶**: `src/å¶åƒå¤§å¸ˆé—ªè€€è‰²å½©-cardgame/types.ts`

```typescript
/**
 * å¡ç‰Œç±»å‹å®šä¹‰
 */

export type CardType = 'Attack' | 'Support' | 'Heal';
export type CardAttribute = 'Vocal' | 'Dance' | 'Visual';
export type CardRarity = 'UR' | 'SSR' | 'SR' | 'R';

/**
 * å¡ç‰Œæ•ˆæœ
 */
export interface CardEffect {
  // åˆ†æ•°å€ç‡ï¼ˆä¾‹å¦‚ï¼šVocal x 2.0ï¼‰
  scoreMultiplier?: number;
  
  // å±æ€§åŠ æˆï¼ˆä¾‹å¦‚ï¼š+20 Vocalï¼‰
  statBonus?: {
    vocal?: number;
    dance?: number;
    visual?: number;
  };
  
  // æŠ½ç‰Œï¼ˆä¾‹å¦‚ï¼šæŠ½2å¼ ç‰Œï¼‰
  draw?: number;
  
  // æ¢å¤ä½“åŠ›
  heal?: number;
  
  // å¢åŠ Hypeå€¼
  hype?: number;
  
  // æè¿°æ–‡æœ¬
  description: string;
}

/**
 * AIç”Ÿæˆçš„æŠ€èƒ½æ•°æ®
 */
export interface AISkillData {
  name: string;
  cost: number;
  type: CardType;
  description: string;
}

/**
 * å¡ç‰Œæ•°æ®
 */
export interface Card {
  id: string;                    // å”¯ä¸€ID
  name: string;                  // å¡ç‰Œåç§°
  cost: number;                  // Costï¼ˆ1-5ï¼‰
  type: CardType;                // ç±»å‹
  attribute: CardAttribute;      // å±æ€§
  effect: CardEffect;            // æ•ˆæœ
  rarity: CardRarity;            // ç¨€æœ‰åº¦
  imageUrl: string;              // å¡é¢å›¾ç‰‡URL
  characterName: string;         // è§’è‰²å
  unique_skill?: AISkillData;    // AIç”Ÿæˆçš„æŠ€èƒ½ï¼ˆå¯é€‰ï¼‰
}

/**
 * å¯¹æ‰‹æ•°æ®
 */
export interface Rival {
  id: string;
  name: string;
  stats: {
    vocal: number;
    dance: number;
    visual: number;
  };
  difficulty: number;  // 0.8 - 1.5
}

/**
 * æ¸¸æˆçŠ¶æ€
 */
export interface GameState {
  currentTurn: number;           // å½“å‰å›åˆ
  maxTurns: number;              // æœ€å¤§å›åˆæ•°
  
  // ç©å®¶çŠ¶æ€
  playerHand: Card[];            // æ‰‹ç‰Œ
  playerField: Card[];           // å·²æ‰“å‡ºçš„å¡
  playerScore: number;           // åˆ†æ•°
  playerStats: {                 // å½“å‰å±æ€§
    vocal: number;
    dance: number;
    visual: number;
  };
  
  // å¯¹æ‰‹çŠ¶æ€
  rivalScore: number;            // å¯¹æ‰‹åˆ†æ•°
  rival: Rival;                  // å¯¹æ‰‹ä¿¡æ¯
  
  // Costç®¡ç†
  availableCost: number;         // å½“å‰å¯ç”¨Cost
  totalCost: number;             // æ€»Costï¼ˆæ¯å›åˆåˆ·æ–°ï¼‰
  
  // æ¸¸æˆç»“æœ
  isGameOver: boolean;
  winner?: 'player' | 'rival' | 'draw';
}
```

---

#### ä»»åŠ¡6: å®ç°Card.vueç»„ä»¶ï¼ˆ1å°æ—¶ï¼‰

**æ–‡ä»¶**: `src/å¶åƒå¤§å¸ˆé—ªè€€è‰²å½©-cardgame/components/Card.vue`

```vue
<template>
  <div
    class="card"
    :class="[
      `rarity-${card.rarity.toLowerCase()}`,
      `type-${card.type.toLowerCase()}`,
      { disabled: !canPlay }
    ]"
    :draggable="canPlay"
    @dragstart="handleDragStart"
    @dragend="handleDragEnd"
  >
    <!-- Costæ˜¾ç¤º -->
    <div class="card-cost">{{ card.cost }}</div>
    
    <!-- å¡é¢å›¾ç‰‡ -->
    <div class="card-image">
      <img :src="card.imageUrl" :alt="card.name" />
    </div>
    
    <!-- å¡ç‰‡ä¿¡æ¯ -->
    <div class="card-info">
      <h3 class="card-name">{{ card.name }}</h3>
      <p class="card-character">{{ card.characterName }}</p>
      <p class="card-description">{{ card.effect.description }}</p>
    </div>
    
    <!-- ç¨€æœ‰åº¦è¾¹æ¡† -->
    <div class="card-border"></div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import type { Card } from '../types';

const props = defineProps<{
  card: Card;
  canPlay?: boolean;
}>();

const emit = defineEmits<{
  dragStart: [card: Card];
  dragEnd: [card: Card];
}>();

const canPlay = computed(() => props.canPlay ?? true);

function handleDragStart(event: DragEvent) {
  if (!canPlay.value) {
    event.preventDefault();
    return;
  }
  
  event.dataTransfer!.effectAllowed = 'move';
  event.dataTransfer!.setData('cardId', props.card.id);
  emit('dragStart', props.card);
}

function handleDragEnd(event: DragEvent) {
  emit('dragEnd', props.card);
}
</script>

<style scoped lang="scss">
.card {
  width: 180px;
  height: 280px;
  border-radius: 12px;
  position: relative;
  cursor: pointer;
  transition: all 0.3s;
  background: white;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
  
  &:hover {
    transform: translateY(-10px) scale(1.05);
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
  }
  
  &.disabled {
    opacity: 0.5;
    cursor: not-allowed;
    
    &:hover {
      transform: none;
    }
  }
  
  // ç¨€æœ‰åº¦è¾¹æ¡†
  &.rarity-ur {
    border: 3px solid #ffd700;
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
  }
  
  &.rarity-ssr {
    border: 3px solid #ff1493;
    box-shadow: 0 0 15px rgba(255, 20, 147, 0.6);
  }
  
  &.rarity-sr {
    border: 3px solid #9370db;
    box-shadow: 0 0 10px rgba(147, 112, 219, 0.6);
  }
  
  &.rarity-r {
    border: 2px solid #999;
  }
}

.card-cost {
  position: absolute;
  top: 10px;
  left: 10px;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  font-size: 24px;
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  z-index: 2;
}

.card-image {
  width: 100%;
  height: 150px;
  overflow: hidden;
  border-radius: 12px 12px 0 0;
  
  img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
}

.card-info {
  padding: 10px;
  
  .card-name {
    margin: 0 0 5px 0;
    font-size: 14px;
    font-weight: bold;
    color: #333;
  }
  
  .card-character {
    margin: 0 0 8px 0;
    font-size: 12px;
    color: #666;
  }
  
  .card-description {
    margin: 0;
    font-size: 11px;
    color: #999;
    line-height: 1.4;
  }
}
</style>
```

---

#### ä»»åŠ¡7: å®ç°CardGame.vueä¸»ç•Œé¢ï¼ˆ1.5å°æ—¶ï¼‰

**æ–‡ä»¶**: `src/å¶åƒå¤§å¸ˆé—ªè€€è‰²å½©-cardgame/app.vue`

```vue
<template>
  <div class="card-game">
    <!-- å¯¹æ‰‹åŒºåŸŸ -->
    <div class="rival-area">
      <div class="rival-info">
        <h2>{{ gameState.rival.name }}</h2>
        <p>åˆ†æ•°: {{ gameState.rivalScore }}</p>
      </div>
      <div class="rival-field">
        <!-- å¯¹æ‰‹æ‰“å‡ºçš„å¡ï¼ˆç®€åŒ–æ˜¾ç¤ºï¼‰ -->
        <div v-for="i in 3" :key="i" class="card-placeholder">
          <i class="fas fa-music"></i>
        </div>
      </div>
    </div>
    
    <!-- åˆ†æ•°æ¿ -->
    <ScoreBoard
      :player-score="gameState.playerScore"
      :rival-score="gameState.rivalScore"
      :current-turn="gameState.currentTurn"
      :max-turns="gameState.maxTurns"
      :available-cost="gameState.availableCost"
      :total-cost="gameState.totalCost"
    />
    
    <!-- ç©å®¶åœºåœ° -->
    <Field
      :cards="gameState.playerField"
      @drop="handleDrop"
    />
    
    <!-- æ‰‹ç‰ŒåŒº -->
    <Hand
      :cards="gameState.playerHand"
      :available-cost="gameState.availableCost"
      @card-drag-start="handleCardDragStart"
      @card-drag-end="handleCardDragEnd"
    />
    
    <!-- æ§åˆ¶æŒ‰é’® -->
    <div class="controls">
      <button class="btn-end-turn" @click="endTurn">
        <i class="fas fa-forward"></i>
        ç»“æŸå›åˆ
      </button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, reactive, onMounted } from 'vue';
import type { GameState, Card } from './types';
import Hand from './components/Hand.vue';
import Field from './components/Field.vue';
import ScoreBoard from './components/ScoreBoard.vue';
import { CardGame } from './game-logic';
import { TEST_RIVALS } from './rival-simulator';

// æ¸¸æˆå®ä¾‹
const game = new CardGame();

// æ¸¸æˆçŠ¶æ€
const gameState = reactive<GameState>({
  currentTurn: 1,
  maxTurns: 10,
  playerHand: [],
  playerField: [],
  playerScore: 0,
  playerStats: { vocal: 300, dance: 300, visual: 300 },
  rivalScore: 0,
  rival: TEST_RIVALS[0],
  availableCost: 3,
  totalCost: 3,
  isGameOver: false
});

// æ‹–æ‹½ä¸­çš„å¡ç‰Œ
const draggingCard = ref<Card | null>(null);

/**
 * åˆå§‹åŒ–æ¸¸æˆ
 */
onMounted(() => {
  // TODO: ä»æŠ½å¡ç³»ç»ŸåŠ è½½ç©å®¶çš„å¡ç»„
  // æš‚æ—¶ä½¿ç”¨æµ‹è¯•å¡ç»„
  game.initGame([], 10);
  
  // åŠ è½½æ¸¸æˆçŠ¶æ€
  Object.assign(gameState, game.getState());
  
  toastr.success('æ¸¸æˆå¼€å§‹ï¼');
});

/**
 * å¤„ç†å¡ç‰Œæ‹–æ‹½å¼€å§‹
 */
function handleCardDragStart(card: Card) {
  draggingCard.value = card;
}

/**
 * å¤„ç†å¡ç‰Œæ‹–æ‹½ç»“æŸ
 */
function handleCardDragEnd(card: Card) {
  draggingCard.value = null;
}

/**
 * å¤„ç†æ”¾ç½®å¡ç‰Œ
 */
function handleDrop(event: DragEvent) {
  if (!draggingCard.value) return;
  
  // å°è¯•æ‰“å‡ºå¡ç‰Œ
  const success = game.playCard(draggingCard.value);
  
  if (success) {
    toastr.success(`æ‰“å‡ºäº† ${draggingCard.value.name}ï¼`);
    Object.assign(gameState, game.getState());
  } else {
    toastr.error('Costä¸è¶³ï¼Œæ— æ³•æ‰“å‡ºæ­¤å¡ï¼');
  }
  
  draggingCard.value = null;
}

/**
 * ç»“æŸå›åˆ
 */
function endTurn() {
  game.endTurn();
  Object.assign(gameState, game.getState());
  
  toastr.info(`ç¬¬ ${gameState.currentTurn} å›åˆå¼€å§‹`);
  
  // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
  if (gameState.isGameOver) {
    handleGameOver();
  }
}

/**
 * å¤„ç†æ¸¸æˆç»“æŸ
 */
function handleGameOver() {
  if (gameState.winner === 'player') {
    toastr.success('ğŸ‰ èƒœåˆ©ï¼');
  } else if (gameState.winner === 'rival') {
    toastr.error('å¤±è´¥äº†...');
  } else {
    toastr.info('å¹³å±€');
  }
}
</script>

<style scoped lang="scss">
.card-game {
  width: 100%;
  height: 100vh;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.rival-area {
  background: rgba(255, 255, 255, 0.1);
  border-radius: 15px;
  padding: 20px;
  
  .rival-info {
    text-align: center;
    color: white;
    margin-bottom: 10px;
    
    h2 {
      margin: 0;
      font-size: 24px;
    }
    
    p {
      margin: 5px 0 0 0;
      font-size: 18px;
    }
  }
  
  .rival-field {
    display: flex;
    justify-content: center;
    gap: 10px;
    
    .card-placeholder {
      width: 100px;
      height: 150px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 48px;
    }
  }
}

.controls {
  display: flex;
  justify-content: center;
  
  .btn-end-turn {
    background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
    color: #333;
    border: none;
    padding: 15px 40px;
    border-radius: 30px;
    font-size: 18px;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 10px;
    box-shadow: 0 4px 15px rgba(255, 215, 0, 0.5);
    transition: all 0.3s;
    
    &:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(255, 215, 0, 0.7);
    }
    
    &:active {
      transform: translateY(0);
    }
  }
}
</style>
```

---

### æ™šä¸Š (19:00 - 21:00)ï¼šæ¸¸æˆé€»è¾‘ä¸å¯¹æ‰‹æ¨¡æ‹Ÿ ğŸ§ 

#### ä»»åŠ¡8: å®ç°æ¸¸æˆæ ¸å¿ƒé€»è¾‘ï¼ˆ1å°æ—¶ï¼‰

**æ–‡ä»¶**: `src/å¶åƒå¤§å¸ˆé—ªè€€è‰²å½©-cardgame/game-logic.ts`

```typescript
import type { Card, GameState, Rival } from './types';
import { calculateRivalScore } from './rival-simulator';

/**
 * å¡ç‰Œæ¸¸æˆæ ¸å¿ƒé€»è¾‘
 */
export class CardGame {
  private state: GameState;
  private deck: Card[];
  
  constructor() {
    this.state = this.getDefaultState();
    this.deck = [];
  }
  
  /**
   * åˆå§‹åŒ–æ¸¸æˆ
   */
  initGame(deck: Card[], maxTurns: number, rival: Rival): void {
    this.deck = [...deck];
    this.state = {
      ...this.getDefaultState(),
      maxTurns,
      rival
    };
    
    // åˆå§‹æŠ½ç‰Œ
    this.drawCards(5);
  }
  
  /**
   * æŠ½ç‰Œ
   */
  drawCards(count: number): void {
    for (let i = 0; i < count && this.deck.length > 0; i++) {
      const card = this.deck.pop()!;
      this.state.playerHand.push(card);
    }
  }
  
  /**
   * æ‰“å‡ºå¡ç‰Œ
   */
  playCard(card: Card): boolean {
    // æ£€æŸ¥Cost
    if (card.cost > this.state.availableCost) {
      return false;
    }
    
    // ä»æ‰‹ç‰Œä¸­ç§»é™¤
    const index = this.state.playerHand.findIndex(c => c.id === card.id);
    if (index === -1) return false;
    this.state.playerHand.splice(index, 1);
    
    // æ·»åŠ åˆ°åœºåœ°
    this.state.playerField.push(card);
    
    // æ‰£é™¤Cost
    this.state.availableCost -= card.cost;
    
    // åº”ç”¨å¡ç‰Œæ•ˆæœ
    this.applyCardEffect(card);
    
    return true;
  }
  
  /**
   * åº”ç”¨å¡ç‰Œæ•ˆæœ
   */
  private applyCardEffect(card: Card): void {
    const effect = card.effect;
    
    // åˆ†æ•°å€ç‡
    if (effect.scoreMultiplier) {
      let baseScore = 0;
      switch (card.attribute) {
        case 'Vocal':
          baseScore = this.state.playerStats.vocal;
          break;
        case 'Dance':
          baseScore = this.state.playerStats.dance;
          break;
        case 'Visual':
          baseScore = this.state.playerStats.visual;
          break;
      }
      this.state.playerScore += baseScore * effect.scoreMultiplier;
    }
    
    // å±æ€§åŠ æˆ
    if (effect.statBonus) {
      if (effect.statBonus.vocal) {
        this.state.playerStats.vocal += effect.statBonus.vocal;
      }
      if (effect.statBonus.dance) {
        this.state.playerStats.dance += effect.statBonus.dance;
      }
      if (effect.statBonus.visual) {
        this.state.playerStats.visual += effect.statBonus.visual;
      }
    }
    
    // æŠ½ç‰Œ
    if (effect.draw) {
      this.drawCards(effect.draw);
    }
  }
  
  /**
   * ç»“æŸå›åˆ
   */
  endTurn(): void {
    // æ¸…ç©ºåœºåœ°
    this.state.playerField = [];
    
    // ä¸‹ä¸€å›åˆ
    this.state.currentTurn++;
    
    // åˆ·æ–°Cost
    this.state.availableCost = this.state.totalCost;
    
    // æŠ½ç‰Œ
    this.drawCards(2);
    
    // æ¨¡æ‹Ÿå¯¹æ‰‹å¾—åˆ†
    this.state.rivalScore += calculateRivalScore(
      this.state.rival,
      this.state.currentTurn,
      this.state.maxTurns
    );
    
    // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
    if (this.state.currentTurn > this.state.maxTurns) {
      this.endGame();
    }
  }
  
  /**
   * ç»“æŸæ¸¸æˆ
   */
  private endGame(): void {
    this.state.isGameOver = true;
    
    if (this.state.playerScore > this.state.rivalScore) {
      this.state.winner = 'player';
    } else if (this.state.playerScore < this.state.rivalScore) {
      this.state.winner = 'rival';
    } else {
      this.state.winner = 'draw';
    }
  }
  
  /**
   * è·å–å½“å‰æ¸¸æˆçŠ¶æ€
   */
  getState(): GameState {
    return { ...this.state };
  }
  
  /**
   * è·å–é»˜è®¤çŠ¶æ€
   */
  private getDefaultState(): GameState {
    return {
      currentTurn: 1,
      maxTurns: 10,
      playerHand: [],
      playerField: [],
      playerScore: 0,
      playerStats: { vocal: 300, dance: 300, visual: 300 },
      rivalScore: 0,
      rival: {
        id: 'test',
        name: 'æµ‹è¯•å¯¹æ‰‹',
        stats: { vocal: 300, dance: 300, visual: 300 },
        difficulty: 1.0
      },
      availableCost: 3,
      totalCost: 3,
      isGameOver: false
    };
  }
}
```

---

#### ä»»åŠ¡9: å®ç°å¯¹æ‰‹æ¨¡æ‹Ÿå™¨ï¼ˆ1å°æ—¶ï¼‰

**æ–‡ä»¶**: `src/å¶åƒå¤§å¸ˆé—ªè€€è‰²å½©-cardgame/rival-simulator.ts`

```typescript
import type { Rival } from './types';

/**
 * è®¡ç®—å¯¹æ‰‹åˆ†æ•°
 */
export function calculateRivalScore(
  rival: Rival,
  turn: number,
  maxTurns: number
): number {
  // åŸºç¡€åˆ†æ•°ï¼ˆåŸºäºä¸‰ç»´å±æ€§ï¼‰
  const base = (rival.stats.vocal + rival.stats.dance + rival.stats.visual) / 3;
  
  // éšæœºå€¼ï¼ˆÂ±20%ï¼‰
  const random = base * 0.2 * (Math.random() * 2 - 1);
  
  // å›åˆåŠ æˆï¼ˆåæœŸåŠ åˆ†ï¼‰
  const turnBonus = (turn / maxTurns) * base * 0.3;
  
  // éš¾åº¦ç³»æ•°
  const score = (base + random + turnBonus) * rival.difficulty;
  
  return Math.max(0, Math.floor(score));
}

/**
 * æµ‹è¯•ç”¨å¯¹æ‰‹
 */
export const TEST_RIVALS: Rival[] = [
  {
    id: 'rival_weak',
    name: 'æ–°æ‰‹å¶åƒ',
    stats: {
      vocal: 200,
      dance: 200,
      visual: 200
    },
    difficulty: 0.8
  },
  {
    id: 'rival_medium',
    name: 'ä¸­åšå¶åƒ',
    stats: {
      vocal: 400,
      dance: 400,
      visual: 400
    },
    difficulty: 1.0
  },
  {
    id: 'rival_strong',
    name: 'é¡¶å°–å¶åƒ',
    stats: {
      vocal: 600,
      dance: 600,
      visual: 600
    },
    difficulty: 1.2
  }
];
```

---

## ğŸ“Š éªŒæ”¶æ ‡å‡†

### å¿…é¡»å®Œæˆï¼ˆP0ï¼‰

**Phase 1.6: iframeé€šä¿¡ç³»ç»Ÿ**
- [x] loaderè„šæœ¬èƒ½åŠ è½½Vueåº”ç”¨
- [x] Vueèƒ½å‘é€æ¶ˆæ¯åˆ°SillyTavern
- [x] STèƒ½æ‹¦æˆªAIå›å¤å¹¶è½¬å‘å›Vue
- [x] é€šä¿¡æµ‹è¯•å…¨éƒ¨é€šè¿‡

**Phase 2.1: å¡ç‰Œæˆ˜æ–—UI**
- [x] Card.vueèƒ½æ­£ç¡®æ˜¾ç¤ºå¡ç‰Œ
- [x] å¡ç‰Œèƒ½æ‹–æ‹½
- [x] èƒ½æ˜¾ç¤ºæ‰‹ç‰Œå’Œåœºåœ°
- [x] èƒ½æ˜¾ç¤ºåˆ†æ•°
- [x] èƒ½ç»“æŸå›åˆ

### æœŸæœ›å®Œæˆï¼ˆP1ï¼‰

- [x] å¡ç‰Œæ•ˆæœèƒ½å®é™…ç”Ÿæ•ˆ
- [x] å¯¹æ‰‹åˆ†æ•°æ¨¡æ‹Ÿå‡†ç¡®
- [x] èƒ½å®Œæ•´è·‘é€šä¸€å±€æ¸¸æˆ
- [x] èƒœè´Ÿåˆ¤å®šæ­£ç¡®

### å¯é€‰å®Œæˆï¼ˆP2ï¼‰

- [ ] å¡ç‰ŒåŠ¨ç”»æ•ˆæœ
- [ ] éŸ³æ•ˆ
- [ ] æ›´å¤æ‚çš„å¡ç‰Œæ•ˆæœ
- [ ] AIå¡ç‰Œç”Ÿæˆæµ‹è¯•

---

## ğŸ“ å·¥ä½œè®°å½•æ¨¡æ¿

**å®Œæˆè¿›åº¦**:
- [ ] Phase 1.6å®Œæˆåº¦: ____%
- [ ] Phase 2.1å®Œæˆåº¦: ____%
- [ ] æ€»ä½“å®Œæˆåº¦: ____%

**é‡åˆ°çš„é—®é¢˜**:
1. 
2. 
3. 

**è§£å†³æ–¹æ¡ˆ**:
1. 
2. 
3. 

**æ˜æ—¥éœ€è¦ç»§ç»­çš„å·¥ä½œ**:
1. 
2. 
3. 

---

## ğŸ¯ æœ¬å‘¨ç›®æ ‡å›é¡¾

### æœ¬å‘¨ä»»åŠ¡ï¼ˆ11æœˆ1æ—¥ - 11æœˆ3æ—¥ï¼‰

**11æœˆ1æ—¥ï¼ˆä»Šå¤©ï¼‰**:
- [x] å®Œæˆiframeé€šä¿¡ç³»ç»Ÿ
- [x] å®Œæˆå¡ç‰Œæˆ˜æ–—UIæ¡†æ¶
- [x] å®Œæˆå¯¹æ‰‹æ¨¡æ‹Ÿå™¨

**11æœˆ2æ—¥ï¼ˆå‘¨å…­ï¼‰**:
- [ ] å®Œå–„å¡ç‰Œæ•ˆæœç³»ç»Ÿ
- [ ] å®ç°æ›´å¤šå¡ç‰Œç±»å‹
- [ ] æµ‹è¯•å®Œæ•´æ¸¸æˆæµç¨‹
- [ ] ä¼˜åŒ–UIå’ŒåŠ¨ç”»

**11æœˆ3æ—¥ï¼ˆå‘¨æ—¥ï¼‰**:
- [ ] å¼€å§‹Phase 2.0ï¼šæç¤ºè¯åŠ å·¥å‚
- [ ] åˆ›å»ºä¸–ç•Œä¹¦åŒºç»“æ„
- [ ] å®ç°PromptFactoryç±»
- [ ] æµ‹è¯•AIå¡ç‰Œç”Ÿæˆ

---

## ğŸ’ª è‡ªæˆ‘æ¿€åŠ±

> "ä»Šå¤©æ˜¯è¿›å…¥æ ¸å¿ƒç©æ³•å¼€å‘çš„ç¬¬ä¸€å¤©ï¼"  
> "æ‰“ç‰Œç³»ç»Ÿæ˜¯æ•´ä¸ªæ¸¸æˆæœ€æ ¸å¿ƒã€æœ€æœ‰è¶£çš„éƒ¨åˆ†ï¼"  
> "ä¸€æ­¥ä¸€æ­¥æ¥ï¼Œå…ˆæŠŠåŸºç¡€æ¡†æ¶æ­å¥½ï¼"  
> "ç›¸ä¿¡è‡ªå·±ï¼Œä½ å¯ä»¥çš„ï¼"

ğŸ® **è®©æˆ‘ä»¬å¼€å§‹å§ï¼**

---

**è®¡åˆ’åˆ¶å®šæ—¶é—´**: 2025-10-31 20:30  
**é¢„è®¡å®Œæˆæ—¶é—´**: 2025-11-01 21:00  
**æœŸå¾…æŒ‡æ•°**: â­â­â­â­â­ (5/5)
















