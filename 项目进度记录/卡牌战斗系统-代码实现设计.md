# å¡ç‰Œæˆ˜æ–—ç³»ç»Ÿ - ä»£ç å®ç°è®¾è®¡

**åˆ›å»ºæ—¶é—´**: 2025-11-01  
**ç›®æ ‡**: å°†æ–‡å­—æè¿°çš„æ¸¸æˆæœºåˆ¶è½¬åŒ–ä¸ºå¯æ‰§è¡Œçš„TypeScriptä»£ç æ¶æ„

---

## ğŸ“‹ ç›®å½•

1. [æ ¸å¿ƒæ•°æ®ç»“æ„](#æ ¸å¿ƒæ•°æ®ç»“æ„)
2. [å±æ€§ç³»ç»Ÿ](#å±æ€§ç³»ç»Ÿ)
3. [Buffç³»ç»Ÿ](#buffç³»ç»Ÿ)
4. [æŠ€èƒ½å¡æ•ˆæœå¼•æ“](#æŠ€èƒ½å¡æ•ˆæœå¼•æ“)
5. [æˆ˜æ–—çŠ¶æ€ç®¡ç†](#æˆ˜æ–—çŠ¶æ€ç®¡ç†)
6. [æ•ˆæœè§£æä¸æ‰§è¡Œ](#æ•ˆæœè§£æä¸æ‰§è¡Œ)
7. [è®¡åˆ†ç³»ç»Ÿ](#è®¡åˆ†ç³»ç»Ÿ)
8. [åŸ¹è‚²è®¡åˆ’æœºåˆ¶](#åŸ¹è‚²è®¡åˆ’æœºåˆ¶)

---

## 1. æ ¸å¿ƒæ•°æ®ç»“æ„

### 1.1 æˆ˜æ–—çŠ¶æ€ï¼ˆBattleStateï¼‰

```typescript
/**
 * æˆ˜æ–—çŠ¶æ€ - å­˜å‚¨ä¸€åœºæˆ˜æ–—/è®­ç»ƒçš„æ‰€æœ‰æ•°æ®
 */
interface BattleState {
  // åŸºç¡€ä¿¡æ¯
  mode: 'training' | 'exam';          // è®­ç»ƒæ¨¡å¼ or æ¯”èµ›æ¨¡å¼
  planType: 'sense' | 'logic' | 'anomaly';  // åŸ¹è‚²è®¡åˆ’ç±»å‹
  currentTurn: number;                // å½“å‰å›åˆï¼ˆ1-basedï¼‰
  maxTurns: number;                   // æœ€å¤§å›åˆæ•°
  
  // èµ„æº
  stamina: number;                    // å½“å‰ä½“åŠ›ï¼ˆ0-100ï¼‰
  maxStamina: number;                 // æœ€å¤§ä½“åŠ›
  genki: number;                      // å…ƒæ°”ï¼ˆ0-100ï¼‰
  
  // å±æ€§ï¼ˆåŸ¹è‚²è®¡åˆ’ç›¸å…³ï¼‰
  attributes: {
    // æ„Ÿæ€§ç³»ç»Ÿ
    concentration: number;            // ä¸“æ³¨ï¼ˆé›†ä¸­ï¼‰
    
    // ç†æ€§ç³»ç»Ÿ
    motivation: number;               // å¹²åŠ²
    goodImpression: number;           // å¥½å°è±¡
    
    // éå‡¡ç³»ç»Ÿ
    allPower: number;                 // å…¨åŠ›å€¼ï¼ˆ0-10ï¼‰
    heat: number;                     // çƒ­æ„å€¼
    anomalyState: 'allout' | 'conserve' | 'resolute' | 'relaxed' | null;  // å››æ€
    stateLevel: 1 | 2;                // çŠ¶æ€é˜¶æ®µï¼ˆä¸€é˜¶æ®µ/äºŒé˜¶æ®µï¼‰
    
    // é€šç”¨
    energy: number;                   // æ´»åŠ›
  };
  
  // ä¸‰ç»´å±æ€§ï¼ˆç”¨äºè®¡åˆ†ï¼‰
  stats: {
    vocal: number;
    dance: number;
    visual: number;
  };
  
  // å¾—åˆ†
  score: {
    current: number;                  // å½“å‰å¾—åˆ†
    target: number;                   // ç›®æ ‡å¾—åˆ†ï¼ˆClearæ ‡å‡†ï¼‰
    perfectTarget: number;            // Perfectç›®æ ‡ï¼ˆ2xï¼‰
  };
  
  // Buffç®¡ç†
  buffs: Map<string, Buff>;           // æ¿€æ´»çš„Buff
  
  // å¡ç‰Œ
  deck: SkillCard[];                  // ç‰Œå †
  hand: SkillCard[];                  // æ‰‹ç‰Œï¼ˆæœ€å¤š5å¼ ï¼‰
  discardPile: SkillCard[];           // å¼ƒç‰Œå †
  removedPile: SkillCard[];           // é™¤å¤–å †
  
  // å›åˆçŠ¶æ€
  turnState: {
    cardsUsed: number;                // æœ¬å›åˆå·²ä½¿ç”¨å¡ç‰Œæ•°
    maxCardsPerTurn: number;          // æœ¬å›åˆæœ€å¤šä½¿ç”¨æ•°ï¼ˆé»˜è®¤1ï¼‰
    drawnThisTurn: number;            // æœ¬å›åˆå·²æŠ½ç‰Œæ•°
    attribute: 'vocal' | 'dance' | 'visual' | null;  // æœ¬å›åˆå±æ€§ï¼ˆæ¯”èµ›æ¨¡å¼ï¼‰
  };
  
  // åº”æ´æ•ˆæœï¼ˆè®­ç»ƒæ¨¡å¼ï¼‰
  support: {
    active: boolean;
    description: string;
    requirement: string;              // è¾¾æˆè¦æ±‚
    reward: any;                      // å¥–åŠ±
    turns: number;                    // å‰©ä½™å›åˆæ•°
  } | null;
}
```

### 1.2 æŠ€èƒ½å¡ï¼ˆSkillCardï¼‰

```typescript
/**
 * æŠ€èƒ½å¡æ•°æ®ç»“æ„
 */
interface SkillCard {
  id: string;                         // å¡ç‰ŒID
  name: string;                       // å¡ç‰Œåç§°
  rarity: 'N' | 'R' | 'SR' | 'SSR';   // ç¨€æœ‰åº¦
  type: 'A' | 'M' | 'T';              // A=ä¸»åŠ¨, M=å¿ƒç†, T=é™·é˜±
  cost: number;                       // å…ƒæ°”æ¶ˆè€—ï¼ˆè´Ÿæ•°ï¼‰
  costType: 'normal' | 'stamina_only'; // ç»¿è‰²å›¾æ ‡/çº¢è‰²å›¾æ ‡
  unique: boolean;                    // æ˜¯å¦"é‡å¤ä¸å¯"
  enhanced: boolean;                  // æ˜¯å¦å·²å¼ºåŒ–
  limitPerLesson: number | null;      // è¯¾ç¨‹ä¸­é™Xæ¬¡ï¼ˆnull=æ— é™åˆ¶ï¼‰
  usedThisLesson: number;             // æœ¬è¯¾ç¨‹å·²ä½¿ç”¨æ¬¡æ•°
  
  // æ•ˆæœå®šä¹‰ï¼ˆæ ¸å¿ƒï¼‰
  effects: SkillCardEffect[];         // æ•ˆæœåˆ—è¡¨
  
  description: string;                // æ•ˆæœæè¿°ï¼ˆæ˜¾ç¤ºç”¨ï¼‰
  imageUrl?: string;                  // å¡é¢URL
}

/**
 * æŠ€èƒ½å¡æ•ˆæœ
 */
interface SkillCardEffect {
  type: EffectType;                   // æ•ˆæœç±»å‹
  target?: EffectTarget;              // ä½œç”¨ç›®æ ‡
  value?: number;                     // æ•°å€¼
  condition?: EffectCondition;        // è§¦å‘æ¡ä»¶
  duration?: number;                  // æŒç»­æ—¶é—´ï¼ˆå›åˆæ•°ï¼‰
  metadata?: Record<string, any>;     // é¢å¤–æ•°æ®
}

/**
 * æ•ˆæœç±»å‹
 */
type EffectType =
  // èµ„æºæ“ä½œ
  | 'recover_stamina'                 // å›å¤ä½“åŠ›
  | 'gain_genki'                      // è·å¾—å…ƒæ°”
  | 'consume_stamina'                 // æ¶ˆè€—ä½“åŠ›
  | 'consume_genki'                   // æ¶ˆè€—å…ƒæ°”
  
  // å±æ€§æ“ä½œ
  | 'add_concentration'               // å¢åŠ ä¸“æ³¨ï¼ˆæ„Ÿæ€§ï¼‰
  | 'add_motivation'                  // å¢åŠ å¹²åŠ²ï¼ˆç†æ€§ï¼‰
  | 'add_good_impression'             // å¢åŠ å¥½å°è±¡ï¼ˆç†æ€§ï¼‰
  | 'add_all_power'                   // å¢åŠ å…¨åŠ›å€¼ï¼ˆéå‡¡ï¼‰
  | 'add_heat'                        // å¢åŠ çƒ­æ„å€¼ï¼ˆéå‡¡ï¼‰
  | 'consume_concentration'           // æ¶ˆè€—ä¸“æ³¨
  | 'consume_motivation'              // æ¶ˆè€—å¹²åŠ²
  
  // Buffæ“ä½œ
  | 'add_buff'                        // å¢åŠ Buff
  | 'remove_buff'                     // ç§»é™¤Buff
  | 'consume_buff'                    // æ¶ˆè€—Buffï¼ˆå‡å°‘å±‚æ•°/å›åˆæ•°ï¼‰
  
  // å¾—åˆ†ç›¸å…³
  | 'add_score'                       // ç›´æ¥åŠ åˆ†
  | 'add_score_multiplier'            // åŠ åˆ†ï¼ˆåŸºäºä¸‰ç»´ï¼‰
  
  // å¡ç‰Œæ“ä½œ
  | 'draw_cards'                      // æŠ½ç‰Œ
  | 'add_card_uses'                   // å¢åŠ æœ¬å›åˆä½¿ç”¨æ•°
  | 'duplicate_next_card'             // ä¸‹ä¸€å¼ å¡æ•ˆæœå‘åŠ¨2æ¬¡
  | 'move_card_to_top'                // å°†å¡ç§»è‡³ç‰Œå †é¡¶
  | 'remove_card'                     // é™¤å¤–å¡ç‰Œ
  
  // å›åˆæ“ä½œ
  | 'add_extra_turn'                  // é¢å¤–å›åˆ
  | 'skip_next_turn'                  // è·³è¿‡ä¸‹ä¸€å›åˆ
  
  // çŠ¶æ€åˆ‡æ¢ï¼ˆéå‡¡ï¼‰
  | 'switch_anomaly_state'            // åˆ‡æ¢éå‡¡çŠ¶æ€
  | 'lock_anomaly_pointer';           // é”å®šæŒ‡é’ˆ

/**
 * æ•ˆæœç›®æ ‡
 */
type EffectTarget = 'self' | 'hand' | 'deck' | 'discard' | 'all';

/**
 * æ•ˆæœæ¡ä»¶
 */
interface EffectCondition {
  type: 'attribute_gte' | 'attribute_lte' | 'buff_exists' | 'turn_range' | 'card_type' | 'custom';
  key?: string;                       // å±æ€§é”®æˆ–Buffç±»å‹
  value?: number | string | boolean;  // æ¯”è¾ƒå€¼
  customCheck?: (state: BattleState) => boolean;  // è‡ªå®šä¹‰æ£€æŸ¥å‡½æ•°
}
```

### 1.3 Buffæ•°æ®ç»“æ„

```typescript
/**
 * Buff/Debuffæ•°æ®ç»“æ„
 */
interface Buff {
  id: string;                         // Buff IDï¼ˆå¦‚ 'good_condition'ï¼‰
  name: string;                       // Buffåç§°ï¼ˆå¦‚ 'å¥½èª¿'ï¼‰
  type: BuffType;                     // Buffç±»å‹
  category: 'positive' | 'negative';  // æ­£é¢/è´Ÿé¢
  stacks: number;                     // å±‚æ•°ï¼ˆç”¨äºé›†ä¸­ã€å¥½å°è±¡ç­‰ï¼‰
  duration: number;                   // æŒç»­å›åˆæ•°ï¼ˆ-1è¡¨ç¤ºæ°¸ä¹…ï¼‰
  effects: BuffEffect[];              // Buffæ•ˆæœ
  iconUrl?: string;                   // å›¾æ ‡URL
}

/**
 * Buffç±»å‹ï¼ˆå­¦å›­å¶åƒå¤§å¸ˆçš„Buffï¼‰
 */
type BuffType =
  // æ„Ÿæ€§ç³»ç»Ÿ
  | 'good_condition'                  // å¥½èª¿ï¼ˆå¾—åˆ†+50%ï¼‰
  | 'concentration'                   // é›†ä¸­ï¼ˆæ¯å±‚+Nåˆ†ï¼‰
  | 'excellent_condition'             // çµ¶å¥½èª¿ï¼ˆå¼ºåŒ–å¥½èª¿ï¼‰
  | 'great_condition'                 // çŠ¶æ€ç»ä½³
  
  // ç†æ€§ç³»ç»Ÿ
  | 'good_impression'                 // å¥½å°è±¡ï¼ˆå›åˆç»“æŸç›´æ¥å¾—åˆ†ï¼‰
  | 'motivated'                       // æœ‰å¹²åŠ²ï¼ˆå…ƒæ°”è·å–é‡+ï¼‰
  
  // éå‡¡ç³»ç»Ÿ
  | 'allout_state'                    // å…¨åŠ›çŠ¶æ€ï¼ˆå¾—åˆ†+200%ï¼‰
  | 'conserve_state'                  // æ¸©å­˜çŠ¶æ€
  | 'resolute_state'                  // åšå†³çŠ¶æ€
  | 'relaxed_state'                   // ã®ã‚“ã³ã‚ŠçŠ¶æ€
  
  // é€šç”¨æ­£é¢
  | 'stamina_reduction'               // ä½“åŠ›æ¶ˆè€—å‡å°‘
  | 'genki_boost'                     // å…ƒæ°”è·å–å¢åŠ 
  | 'score_boost'                     // å¾—åˆ†å¢åŠ 
  | 'card_draw_boost'                 // æŠ½ç‰Œæ•°å¢åŠ 
  
  // è´Ÿé¢
  | 'tired'                           // ç–²åŠ³ï¼ˆå¾—åˆ†-20%ï¼‰
  | 'confused'                        // æ··ä¹±ï¼ˆéšæœºæ•ˆæœï¼‰
  | 'locked';                         // é”å®šï¼ˆæ— æ³•ä½¿ç”¨å¡ç‰Œï¼‰

/**
 * Buffæ•ˆæœ
 */
interface BuffEffect {
  trigger: BuffTrigger;               // è§¦å‘æ—¶æœº
  effect: (state: BattleState, context?: any) => void;  // æ•ˆæœå‡½æ•°
}

/**
 * Buffè§¦å‘æ—¶æœº
 */
type BuffTrigger =
  | 'turn_start'                      // å›åˆå¼€å§‹æ—¶
  | 'turn_end'                        // å›åˆç»“æŸæ—¶
  | 'card_used'                       // ä½¿ç”¨å¡ç‰Œæ—¶
  | 'score_calculated'                // è®¡ç®—å¾—åˆ†æ—¶
  | 'damage_taken'                    // å—åˆ°ä¼¤å®³æ—¶
  | 'buff_gained'                     // è·å¾—Buffæ—¶
  | 'buff_lost';                      // å¤±å»Buffæ—¶
```

---

## 2. å±æ€§ç³»ç»Ÿï¼ˆAttributeManagerï¼‰

### 2.1 å±æ€§ç®¡ç†å™¨ç±»

```typescript
/**
 * å±æ€§ç®¡ç†å™¨ - å¤„ç†æ‰€æœ‰å±æ€§çš„å¢å‡å’ŒæŸ¥è¯¢
 */
class AttributeManager {
  private state: BattleState;
  
  constructor(state: BattleState) {
    this.state = state;
  }
  
  /**
   * å¢åŠ å±æ€§å€¼
   */
  add(attributeName: keyof BattleState['attributes'], value: number): void {
    const current = this.state.attributes[attributeName] as number;
    this.state.attributes[attributeName] = Math.max(0, current + value) as any;
    
    // è§¦å‘ç›¸å…³äº‹ä»¶
    this.onAttributeChanged(attributeName, value);
  }
  
  /**
   * æ¶ˆè€—å±æ€§å€¼ï¼ˆè¿”å›æ˜¯å¦æˆåŠŸï¼‰
   */
  consume(attributeName: keyof BattleState['attributes'], value: number): boolean {
    const current = this.state.attributes[attributeName] as number;
    if (current < value) {
      return false;  // èµ„æºä¸è¶³
    }
    this.state.attributes[attributeName] = (current - value) as any;
    this.onAttributeChanged(attributeName, -value);
    return true;
  }
  
  /**
   * è·å–å±æ€§å€¼
   */
  get(attributeName: keyof BattleState['attributes']): number {
    return this.state.attributes[attributeName] as number;
  }
  
  /**
   * å±æ€§å˜åŒ–å›è°ƒ
   */
  private onAttributeChanged(attributeName: string, delta: number): void {
    // è§¦å‘UIæ›´æ–°
    EventBus.emit('attribute_changed', { attributeName, delta });
    
    // ç‰¹æ®Šå¤„ç†ï¼šå…¨åŠ›å€¼æ»¡10
    if (attributeName === 'allPower' && this.get('allPower') >= 10) {
      this.triggerAllPowerTransform();
    }
  }
  
  /**
   * å…¨åŠ›å€¼è½¬åŒ–ï¼ˆéå‡¡ç³»ç»Ÿï¼‰
   */
  private triggerAllPowerTransform(): void {
    // æ¶ˆè€—10å…¨åŠ›å€¼ï¼Œåˆ‡æ¢åˆ°å…¨åŠ›çŠ¶æ€
    this.state.attributes.allPower = 0;
    this.state.attributes.anomalyState = 'allout';
    this.state.attributes.stateLevel = 1;
    
    // æ·»åŠ å…¨åŠ›çŠ¶æ€Buff
    BuffManager.addBuff(this.state, {
      id: 'allout_state',
      name: 'å…¨åŠ›çŠ¶æ€',
      type: 'allout_state',
      category: 'positive',
      stacks: 1,
      duration: 3,  // æŒç»­3å›åˆ
      effects: [
        {
          trigger: 'score_calculated',
          effect: (state) => {
            // å¾—åˆ†+200%
            state.score.current *= 3;
          }
        }
      ]
    });
  }
}
```

### 2.2 èµ„æºç³»ç»Ÿï¼ˆä½“åŠ›ã€å…ƒæ°”ï¼‰

```typescript
/**
 * èµ„æºç®¡ç†å™¨ - å¤„ç†ä½“åŠ›å’Œå…ƒæ°”
 */
class ResourceManager {
  /**
   * å›å¤ä½“åŠ›
   */
  static recoverStamina(state: BattleState, amount: number): void {
    const oldStamina = state.stamina;
    state.stamina = Math.min(state.maxStamina, state.stamina + amount);
    const actualRecovered = state.stamina - oldStamina;
    
    EventBus.emit('stamina_changed', { delta: actualRecovered });
  }
  
  /**
   * æ¶ˆè€—ä½“åŠ›ï¼ˆè¿”å›æ˜¯å¦æˆåŠŸï¼‰
   */
  static consumeStamina(state: BattleState, amount: number): boolean {
    // æ£€æŸ¥ä½“åŠ›æ¶ˆè€—å‡å°‘Buff
    const reduction = BuffManager.getBuffEffect(state, 'stamina_reduction');
    const actualCost = Math.max(0, amount - reduction);
    
    if (state.stamina < actualCost) {
      return false;  // ä½“åŠ›ä¸è¶³
    }
    
    state.stamina -= actualCost;
    EventBus.emit('stamina_changed', { delta: -actualCost });
    return true;
  }
  
  /**
   * å¢åŠ å…ƒæ°”
   */
  static gainGenki(state: BattleState, amount: number): void {
    // æ£€æŸ¥å…ƒæ°”å¢åŠ Buff
    const boost = BuffManager.getBuffEffect(state, 'genki_boost');
    const actualGain = amount + boost;
    
    state.genki = Math.min(100, state.genki + actualGain);
    EventBus.emit('genki_changed', { delta: actualGain });
  }
  
  /**
   * æ¶ˆè€—å…ƒæ°”ï¼ˆè¿”å›æ˜¯å¦æˆåŠŸï¼‰
   */
  static consumeGenki(state: BattleState, amount: number): boolean {
    if (state.genki < amount) {
      return false;
    }
    state.genki -= amount;
    EventBus.emit('genki_changed', { delta: -amount });
    return true;
  }
}
```

---

## 3. Buffç³»ç»Ÿï¼ˆBuffManagerï¼‰

### 3.1 Buffç®¡ç†å™¨ç±»

```typescript
/**
 * Buffç®¡ç†å™¨ - å¤„ç†æ‰€æœ‰Buffçš„å¢åˆ æ”¹æŸ¥
 */
class BuffManager {
  /**
   * æ·»åŠ Buff
   */
  static addBuff(state: BattleState, buff: Buff): void {
    const existing = state.buffs.get(buff.id);
    
    if (existing) {
      // å·²å­˜åœ¨åŒç±»Buff
      if (buff.type === 'concentration' || buff.type === 'good_impression') {
        // å¯å åŠ å‹ï¼šå¢åŠ å±‚æ•°
        existing.stacks += buff.stacks;
      } else {
        // åˆ·æ–°å‹ï¼šé‡ç½®æŒç»­æ—¶é—´
        existing.duration = buff.duration;
      }
    } else {
      // æ–°Buff
      state.buffs.set(buff.id, buff);
    }
    
    // è§¦å‘Buffè·å¾—äº‹ä»¶
    this.triggerBuffEffects(state, buff, 'buff_gained');
    EventBus.emit('buff_added', { buff });
  }
  
  /**
   * ç§»é™¤Buff
   */
  static removeBuff(state: BattleState, buffId: string): void {
    const buff = state.buffs.get(buffId);
    if (!buff) return;
    
    state.buffs.delete(buffId);
    
    // è§¦å‘Buffå¤±å»äº‹ä»¶
    this.triggerBuffEffects(state, buff, 'buff_lost');
    EventBus.emit('buff_removed', { buff });
  }
  
  /**
   * æ¶ˆè€—Buffï¼ˆå‡å°‘å±‚æ•°æˆ–å›åˆæ•°ï¼‰
   */
  static consumeBuff(state: BattleState, buffId: string, amount: number = 1): boolean {
    const buff = state.buffs.get(buffId);
    if (!buff) return false;
    
    if (buff.stacks > 0) {
      // å‡å°‘å±‚æ•°
      buff.stacks -= amount;
      if (buff.stacks <= 0) {
        this.removeBuff(state, buffId);
      }
      return true;
    } else if (buff.duration > 0) {
      // å‡å°‘å›åˆæ•°
      buff.duration -= amount;
      if (buff.duration <= 0) {
        this.removeBuff(state, buffId);
      }
      return true;
    }
    
    return false;
  }
  
  /**
   * å›åˆå¼€å§‹æ—¶æ›´æ–°Buff
   */
  static updateBuffsOnTurnStart(state: BattleState): void {
    for (const [buffId, buff] of state.buffs.entries()) {
      // è§¦å‘å›åˆå¼€å§‹æ•ˆæœ
      this.triggerBuffEffects(state, buff, 'turn_start');
      
      // å‡å°‘æŒç»­æ—¶é—´
      if (buff.duration > 0) {
        buff.duration--;
        if (buff.duration === 0) {
          this.removeBuff(state, buffId);
        }
      }
    }
  }
  
  /**
   * å›åˆç»“æŸæ—¶æ›´æ–°Buff
   */
  static updateBuffsOnTurnEnd(state: BattleState): void {
    for (const [_, buff] of state.buffs.entries()) {
      // è§¦å‘å›åˆç»“æŸæ•ˆæœï¼ˆå¦‚å¥½å°è±¡ï¼‰
      this.triggerBuffEffects(state, buff, 'turn_end');
    }
  }
  
  /**
   * è§¦å‘Buffæ•ˆæœ
   */
  private static triggerBuffEffects(state: BattleState, buff: Buff, trigger: BuffTrigger, context?: any): void {
    for (const buffEffect of buff.effects) {
      if (buffEffect.trigger === trigger) {
        buffEffect.effect(state, context);
      }
    }
  }
  
  /**
   * è·å–Buffæ•ˆæœå€¼ï¼ˆç”¨äºæŸ¥è¯¢ï¼‰
   */
  static getBuffEffect(state: BattleState, buffType: BuffType): number {
    let total = 0;
    for (const [_, buff] of state.buffs.entries()) {
      if (buff.type === buffType) {
        total += buff.stacks || 1;
      }
    }
    return total;
  }
  
  /**
   * æ£€æŸ¥æ˜¯å¦æœ‰Buff
   */
  static hasBuff(state: BattleState, buffType: BuffType): boolean {
    for (const [_, buff] of state.buffs.entries()) {
      if (buff.type === buffType) {
        return true;
      }
    }
    return false;
  }
}
```

### 3.2 Buffé¢„è®¾ï¼ˆå¸¸ç”¨Buffï¼‰

```typescript
/**
 * Buffé¢„è®¾åº“
 */
const BuffPresets = {
  // æ„Ÿæ€§ç³»ç»Ÿ
  å¥½èª¿: (duration: number = 3): Buff => ({
    id: 'good_condition',
    name: 'å¥½èª¿',
    type: 'good_condition',
    category: 'positive',
    stacks: 0,
    duration: duration,
    effects: [
      {
        trigger: 'score_calculated',
        effect: (state) => {
          state.score.current *= 1.5;  // å¾—åˆ†+50%
        }
      }
    ]
  }),
  
  é›†ä¸­: (stacks: number = 1): Buff => ({
    id: 'concentration',
    name: 'é›†ä¸­',
    type: 'concentration',
    category: 'positive',
    stacks: stacks,
    duration: -1,  // æ°¸ä¹…ï¼ˆç›´åˆ°æ¶ˆè€—ï¼‰
    effects: [
      {
        trigger: 'score_calculated',
        effect: (state, context) => {
          const buff = state.buffs.get('concentration')!;
          state.score.current += buff.stacks * 15;  // æ¯å±‚+15åˆ†
        }
      }
    ]
  }),
  
  // ç†æ€§ç³»ç»Ÿ
  å¥½å°è±¡: (stacks: number = 1): Buff => ({
    id: 'good_impression',
    name: 'å¥½å°è±¡',
    type: 'good_impression',
    category: 'positive',
    stacks: stacks,
    duration: -1,
    effects: [
      {
        trigger: 'turn_end',
        effect: (state) => {
          const buff = state.buffs.get('good_impression')!;
          const score = buff.stacks * 10;  // æ¯å±‚å›åˆç»“æŸè·å¾—10åˆ†
          state.score.current += score;
          EventBus.emit('good_impression_scored', { score });
        }
      }
    ]
  }),
  
  æœ‰å¹²åŠ²: (duration: number = 3): Buff => ({
    id: 'motivated',
    name: 'æœ‰å¹²åŠ²',
    type: 'motivated',
    category: 'positive',
    stacks: 0,
    duration: duration,
    effects: [
      {
        trigger: 'buff_gained',  // å½“è·å¾—æ­¤Buffæ—¶
        effect: (state) => {
          // å…ƒæ°”è·å–é‡+30%ï¼ˆå®ç°åœ¨ResourceManagerä¸­ï¼‰
        }
      }
    ]
  }),
  
  // éå‡¡ç³»ç»Ÿ
  å…¨åŠ›çŠ¶æ€: (level: 1 | 2 = 1): Buff => ({
    id: `allout_state_${level}`,
    name: `å…¨åŠ›çŠ¶æ€ï¼ˆ${level === 1 ? 'ä¸€é˜¶æ®µ' : 'äºŒé˜¶æ®µ'}ï¼‰`,
    type: 'allout_state',
    category: 'positive',
    stacks: level,
    duration: 3,
    effects: [
      {
        trigger: 'score_calculated',
        effect: (state, context) => {
          if (level === 1) {
            state.score.current *= 3;  // å¾—åˆ†+200%
          } else {
            state.score.current *= 4;  // å¾—åˆ†+300%
          }
        }
      }
    ]
  }),
  
  // é€šç”¨
  ä½“åŠ›æ¶ˆè€—å‡å°‘: (reduction: number = 1, duration: number = 3): Buff => ({
    id: 'stamina_reduction',
    name: `ä½“åŠ›æ¶ˆè€—-${reduction}`,
    type: 'stamina_reduction',
    category: 'positive',
    stacks: reduction,
    duration: duration,
    effects: []  // æ•ˆæœåœ¨ResourceManagerä¸­å¤„ç†
  })
};
```

---

## 4. æŠ€èƒ½å¡æ•ˆæœå¼•æ“ï¼ˆSkillCardExecutorï¼‰

### 4.1 æ•ˆæœæ‰§è¡Œå™¨

```typescript
/**
 * æŠ€èƒ½å¡æ•ˆæœæ‰§è¡Œå™¨ - æ ¸å¿ƒå¼•æ“
 */
class SkillCardExecutor {
  /**
   * æ‰§è¡ŒæŠ€èƒ½å¡
   */
  static async execute(state: BattleState, card: SkillCard): Promise<ExecutionResult> {
    const result: ExecutionResult = {
      success: false,
      logs: [],
      scoreGained: 0
    };
    
    // 1. æ£€æŸ¥ä½¿ç”¨æ¡ä»¶
    if (!this.canUseCard(state, card)) {
      result.logs.push('æ— æ³•ä½¿ç”¨æ­¤å¡ç‰Œï¼ˆæ¡ä»¶ä¸æ»¡è¶³ï¼‰');
      return result;
    }
    
    // 2. æ¶ˆè€—èµ„æºï¼ˆCostï¼‰
    if (!this.consumeCardCost(state, card)) {
      result.logs.push('èµ„æºä¸è¶³ï¼Œæ— æ³•ä½¿ç”¨');
      return result;
    }
    
    // 3. æ‰§è¡Œæ‰€æœ‰æ•ˆæœ
    for (const effect of card.effects) {
      const effectResult = await this.executeEffect(state, effect, card);
      result.logs.push(...effectResult.logs);
      result.scoreGained += effectResult.scoreGained;
    }
    
    // 4. æ›´æ–°å¡ç‰Œä½¿ç”¨æ¬¡æ•°
    card.usedThisLesson++;
    state.turnState.cardsUsed++;
    
    // 5. å°†å¡ç‰Œç§»è‡³å¼ƒç‰Œå †
    const handIndex = state.hand.indexOf(card);
    if (handIndex !== -1) {
      state.hand.splice(handIndex, 1);
      state.discardPile.push(card);
    }
    
    result.success = true;
    return result;
  }
  
  /**
   * æ£€æŸ¥æ˜¯å¦å¯ä»¥ä½¿ç”¨å¡ç‰Œ
   */
  private static canUseCard(state: BattleState, card: SkillCard): boolean {
    // 1. æ£€æŸ¥å›åˆä½¿ç”¨æ¬¡æ•°
    if (state.turnState.cardsUsed >= state.turnState.maxCardsPerTurn) {
      return false;
    }
    
    // 2. æ£€æŸ¥è¯¾ç¨‹é™åˆ¶
    if (card.limitPerLesson !== null && card.usedThisLesson >= card.limitPerLesson) {
      return false;
    }
    
    // 3. æ£€æŸ¥é‡å¤ä¸å¯
    if (card.unique && card.usedThisLesson > 0) {
      return false;
    }
    
    // 4. æ£€æŸ¥èµ„æºæ˜¯å¦è¶³å¤Ÿ
    if (card.costType === 'stamina_only') {
      if (state.stamina < Math.abs(card.cost)) {
        return false;
      }
    } else {
      // å…ƒæ°”ä¼˜å…ˆï¼Œä¸è¶³æ—¶æ¶ˆè€—ä½“åŠ›
      const costAbs = Math.abs(card.cost);
      if (state.genki < costAbs && state.stamina < (costAbs - state.genki)) {
        return false;
      }
    }
    
    return true;
  }
  
  /**
   * æ¶ˆè€—å¡ç‰ŒCost
   */
  private static consumeCardCost(state: BattleState, card: SkillCard): boolean {
    const costAbs = Math.abs(card.cost);
    
    if (card.costType === 'stamina_only') {
      // çº¢è‰²å›¾æ ‡ï¼šåªæ¶ˆè€—ä½“åŠ›
      return ResourceManager.consumeStamina(state, costAbs);
    } else {
      // ç»¿è‰²å›¾æ ‡ï¼šå…ƒæ°”ä¼˜å…ˆï¼Œä¸è¶³æ—¶æ¶ˆè€—ä½“åŠ›
      if (state.genki >= costAbs) {
        return ResourceManager.consumeGenki(state, costAbs);
      } else {
        const remaining = costAbs - state.genki;
        ResourceManager.consumeGenki(state, state.genki);
        return ResourceManager.consumeStamina(state, remaining);
      }
    }
  }
  
  /**
   * æ‰§è¡Œå•ä¸ªæ•ˆæœ
   */
  private static async executeEffect(
    state: BattleState, 
    effect: SkillCardEffect, 
    card: SkillCard
  ): Promise<EffectExecutionResult> {
    const result: EffectExecutionResult = {
      logs: [],
      scoreGained: 0
    };
    
    // æ£€æŸ¥æ¡ä»¶
    if (effect.condition && !this.checkCondition(state, effect.condition)) {
      result.logs.push(`æ¡ä»¶ä¸æ»¡è¶³ï¼Œæ•ˆæœæœªè§¦å‘`);
      return result;
    }
    
    // æ‰§è¡Œæ•ˆæœï¼ˆswitch-caseï¼‰
    switch (effect.type) {
      case 'recover_stamina':
        ResourceManager.recoverStamina(state, effect.value!);
        result.logs.push(`å›å¤ä½“åŠ› ${effect.value}`);
        break;
      
      case 'gain_genki':
        ResourceManager.gainGenki(state, effect.value!);
        result.logs.push(`è·å¾—å…ƒæ°” ${effect.value}`);
        break;
      
      case 'add_concentration':
        const attrMgr = new AttributeManager(state);
        attrMgr.add('concentration', effect.value!);
        result.logs.push(`ä¸“æ³¨ +${effect.value}`);
        break;
      
      case 'add_motivation':
        new AttributeManager(state).add('motivation', effect.value!);
        result.logs.push(`å¹²åŠ² +${effect.value}`);
        break;
      
      case 'add_good_impression':
        new AttributeManager(state).add('goodImpression', effect.value!);
        result.logs.push(`å¥½å°è±¡ +${effect.value}`);
        break;
      
      case 'add_buff':
        const buff = this.createBuffFromMetadata(effect.metadata!);
        BuffManager.addBuff(state, buff);
        result.logs.push(`è·å¾—Buff: ${buff.name}`);
        break;
      
      case 'add_score':
        state.score.current += effect.value!;
        result.scoreGained = effect.value!;
        result.logs.push(`å¾—åˆ† +${effect.value}`);
        break;
      
      case 'add_score_multiplier':
        const attribute = effect.metadata!.attribute as 'vocal' | 'dance' | 'visual';
        const multiplier = effect.value!;
        const baseScore = state.stats[attribute] * multiplier;
        
        // åº”ç”¨Buffä¿®æ­£
        let finalScore = baseScore;
        if (BuffManager.hasBuff(state, 'good_condition')) {
          finalScore *= 1.5;
        }
        if (BuffManager.hasBuff(state, 'allout_state')) {
          finalScore *= 3;
        }
        
        state.score.current += finalScore;
        result.scoreGained = finalScore;
        result.logs.push(`è·å¾— [${attribute}] Ã— ${multiplier} = ${finalScore.toFixed(0)} åˆ†`);
        break;
      
      case 'draw_cards':
        this.drawCards(state, effect.value!);
        result.logs.push(`æŠ½ ${effect.value} å¼ ç‰Œ`);
        break;
      
      case 'add_card_uses':
        state.turnState.maxCardsPerTurn += effect.value!;
        result.logs.push(`æŠ€èƒ½å¡ä½¿ç”¨æ•° +${effect.value}`);
        break;
      
      case 'duplicate_next_card':
        // æ·»åŠ ç‰¹æ®ŠBuffï¼šä¸‹ä¸€å¼ å¡æ•ˆæœå‘åŠ¨2æ¬¡
        BuffManager.addBuff(state, {
          id: 'duplicate_next',
          name: 'ä¸‹ä¸€å¼ å¡æ•ˆæœÃ—2',
          type: 'score_boost' as any,
          category: 'positive',
          stacks: 1,
          duration: 1,
          effects: []
        });
        result.logs.push(`ä¸‹ä¸€å¼ å¡æ•ˆæœå‘åŠ¨2æ¬¡`);
        break;
      
      case 'switch_anomaly_state':
        const targetState = effect.metadata!.state as 'allout' | 'conserve' | 'resolute' | 'relaxed';
        state.attributes.anomalyState = targetState;
        result.logs.push(`åˆ‡æ¢è‡³${targetState}çŠ¶æ€`);
        break;
      
      default:
        result.logs.push(`æœªçŸ¥æ•ˆæœ: ${effect.type}`);
    }
    
    return result;
  }
  
  /**
   * æ£€æŸ¥æ•ˆæœæ¡ä»¶
   */
  private static checkCondition(state: BattleState, condition: EffectCondition): boolean {
    switch (condition.type) {
      case 'attribute_gte':
        const attrValue = new AttributeManager(state).get(condition.key! as any);
        return attrValue >= (condition.value as number);
      
      case 'buff_exists':
        return BuffManager.hasBuff(state, condition.value as BuffType);
      
      case 'turn_range':
        const [min, max] = condition.value as [number, number];
        return state.currentTurn >= min && state.currentTurn <= max;
      
      case 'custom':
        return condition.customCheck!(state);
      
      default:
        return true;
    }
  }
  
  /**
   * æŠ½ç‰Œ
   */
  private static drawCards(state: BattleState, count: number): void {
    for (let i = 0; i < count; i++) {
      if (state.hand.length >= 5) break;  // æ‰‹ç‰Œä¸Šé™5å¼ 
      
      if (state.deck.length === 0) {
        // ç‰Œå †ä¸ºç©ºï¼Œæ´—ç‰Œ
        this.shuffleDeck(state);
      }
      
      if (state.deck.length > 0) {
        const card = state.deck.pop()!;
        state.hand.push(card);
      }
    }
  }
  
  /**
   * æ´—ç‰Œï¼ˆå¼ƒç‰Œå † â†’ ç‰Œå †ï¼‰
   */
  private static shuffleDeck(state: BattleState): void {
    state.deck = [...state.discardPile];
    state.discardPile = [];
    
    // Fisher-Yatesæ´—ç‰Œç®—æ³•
    for (let i = state.deck.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [state.deck[i], state.deck[j]] = [state.deck[j], state.deck[i]];
    }
  }
  
  /**
   * ä»metadataåˆ›å»ºBuff
   */
  private static createBuffFromMetadata(metadata: Record<string, any>): Buff {
    const buffType = metadata.buffType as BuffType;
    
    switch (buffType) {
      case 'good_condition':
        return BuffPresets.å¥½èª¿(metadata.duration || 3);
      case 'concentration':
        return BuffPresets.é›†ä¸­(metadata.stacks || 1);
      case 'good_impression':
        return BuffPresets.å¥½å°è±¡(metadata.stacks || 1);
      default:
        throw new Error(`æœªçŸ¥çš„Buffç±»å‹: ${buffType}`);
    }
  }
}

/**
 * æ‰§è¡Œç»“æœ
 */
interface ExecutionResult {
  success: boolean;
  logs: string[];
  scoreGained: number;
}

interface EffectExecutionResult {
  logs: string[];
  scoreGained: number;
}
```

---

## 5. æˆ˜æ–—çŠ¶æ€ç®¡ç†ï¼ˆBattleControllerï¼‰

### 5.1 æˆ˜æ–—æ§åˆ¶å™¨

```typescript
/**
 * æˆ˜æ–—æ§åˆ¶å™¨ - ç®¡ç†æ•´ä¸ªæˆ˜æ–—/è®­ç»ƒæµç¨‹
 */
class BattleController {
  private state: BattleState;
  
  constructor(config: BattleConfig) {
    this.state = this.initializeState(config);
  }
  
  /**
   * åˆå§‹åŒ–æˆ˜æ–—çŠ¶æ€
   */
  private initializeState(config: BattleConfig): BattleState {
    return {
      mode: config.mode,
      planType: config.planType,
      currentTurn: 1,
      maxTurns: config.maxTurns || 12,
      
      stamina: config.initialStamina || 60,
      maxStamina: config.maxStamina || 60,
      genki: 0,
      
      attributes: {
        concentration: 0,
        motivation: 0,
        goodImpression: 0,
        allPower: 0,
        heat: 0,
        anomalyState: null,
        stateLevel: 1,
        energy: 0
      },
      
      stats: config.stats,
      
      score: {
        current: 0,
        target: config.targetScore || 1000,
        perfectTarget: config.perfectScore || 2000
      },
      
      buffs: new Map(),
      
      deck: [...config.skillDeck],
      hand: [],
      discardPile: [],
      removedPile: [],
      
      turnState: {
        cardsUsed: 0,
        maxCardsPerTurn: 1,
        drawnThisTurn: 0,
        attribute: null
      },
      
      support: config.support || null
    };
  }
  
  /**
   * å¼€å§‹æˆ˜æ–—
   */
  async startBattle(): Promise<void> {
    // æ´—ç‰Œ
    this.shuffleDeck();
    
    // æŠ½åˆå§‹æ‰‹ç‰Œï¼ˆ3å¼ ï¼‰
    this.drawCards(3);
    
    // è¿›å…¥ç¬¬ä¸€å›åˆ
    await this.startTurn();
  }
  
  /**
   * å¼€å§‹å›åˆ
   */
  async startTurn(): Promise<void> {
    console.log(`=== å›åˆ ${this.state.currentTurn} / ${this.state.maxTurns} ===`);
    
    // 1. å›åˆå¼€å§‹æ—¶çš„Buffæ•ˆæœ
    BuffManager.updateBuffsOnTurnStart(this.state);
    
    // 2. æ¯”èµ›æ¨¡å¼ï¼šå†³å®šæœ¬å›åˆå±æ€§
    if (this.state.mode === 'exam') {
      this.determineRoundAttribute();
    }
    
    // 3. æŠ½ç‰Œï¼ˆæ¯å›åˆé»˜è®¤æŠ½3å¼ ï¼‰
    this.drawCards(3);
    
    // 4. é‡ç½®å›åˆçŠ¶æ€
    this.state.turnState.cardsUsed = 0;
    this.state.turnState.maxCardsPerTurn = 1;  // å¯é€šè¿‡å¡ç‰Œæ•ˆæœå¢åŠ 
    this.state.turnState.drawnThisTurn = 3;
    
    // 5. è§¦å‘UIæ›´æ–°
    EventBus.emit('turn_started', { turn: this.state.currentTurn });
  }
  
  /**
   * ä½¿ç”¨å¡ç‰Œ
   */
  async useCard(card: SkillCard): Promise<ExecutionResult> {
    const result = await SkillCardExecutor.execute(this.state, card);
    
    // è§¦å‘UIæ›´æ–°
    EventBus.emit('card_used', { card, result });
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦è§¦å‘"ä¸‹ä¸€å¼ å¡æ•ˆæœÃ—2"
    if (BuffManager.hasBuff(this.state, 'score_boost' as any)) {
      // TODO: é‡å¤æ‰§è¡Œ
    }
    
    return result;
  }
  
  /**
   * è·³è¿‡å‡ºç‰Œ
   */
  skipAction(): void {
    // å›å¤2ç‚¹ä½“åŠ›
    ResourceManager.recoverStamina(this.state, 2);
    
    // ç»“æŸå›åˆ
    this.endTurn();
  }
  
  /**
   * ç»“æŸå›åˆ
   */
  async endTurn(): Promise<void> {
    // 1. å›åˆç»“æŸæ—¶çš„Buffæ•ˆæœï¼ˆå¦‚å¥½å°è±¡ï¼‰
    BuffManager.updateBuffsOnTurnEnd(this.state);
    
    // 2. æ£€æŸ¥æ˜¯å¦è¾¾æˆæ”¯æ´æ•ˆæœ
    if (this.state.support && this.state.support.active) {
      // TODO: æ£€æŸ¥æ”¯æ´è¾¾æˆæ¡ä»¶
    }
    
    // 3. è§¦å‘UIæ›´æ–°
    EventBus.emit('turn_ended', { turn: this.state.currentTurn });
    
    // 4. æ£€æŸ¥æˆ˜æ–—æ˜¯å¦ç»“æŸ
    if (this.state.currentTurn >= this.state.maxTurns) {
      await this.endBattle();
      return;
    }
    
    // 5. è¿›å…¥ä¸‹ä¸€å›åˆ
    this.state.currentTurn++;
    await this.startTurn();
  }
  
  /**
   * ç»“æŸæˆ˜æ–—
   */
  async endBattle(): Promise<BattleResult> {
    const evaluation = this.evaluateResult();
    
    EventBus.emit('battle_ended', { result: evaluation });
    
    return evaluation;
  }
  
  /**
   * è¯„ä¼°ç»“æœ
   */
  private evaluateResult(): BattleResult {
    const { score, mode } = this.state;
    
    let evaluation: 'perfect' | 'clear' | 'fail';
    if (score.current >= score.perfectTarget) {
      evaluation = 'perfect';
    } else if (score.current >= score.target) {
      evaluation = 'clear';
    } else {
      evaluation = 'fail';
    }
    
    return {
      mode: mode,
      evaluation: evaluation,
      finalScore: score.current,
      targetScore: score.target,
      perfectScore: score.perfectTarget,
      turns: this.state.currentTurn,
      remainingStamina: this.state.stamina
    };
  }
  
  /**
   * å†³å®šæœ¬å›åˆå±æ€§ï¼ˆæ¯”èµ›æ¨¡å¼ï¼‰
   */
  private determineRoundAttribute(): void {
    // TODO: æ ¹æ®å®¡æŸ¥åŸºå‡†å†³å®šå±æ€§
    // æœ€åä¸‰å›åˆå›ºå®šä¸ºä¸»å±æ€§
    if (this.state.currentTurn > this.state.maxTurns - 3) {
      this.state.turnState.attribute = 'vocal';  // ç¤ºä¾‹
    } else {
      // éšæœºæˆ–æŒ‰è§„åˆ™
      const attrs: ('vocal' | 'dance' | 'visual')[] = ['vocal', 'dance', 'visual'];
      this.state.turnState.attribute = attrs[Math.floor(Math.random() * 3)];
    }
    
    console.log(`æœ¬å›åˆå±æ€§: ${this.state.turnState.attribute}`);
  }
  
  /**
   * æ´—ç‰Œ
   */
  private shuffleDeck(): void {
    for (let i = this.state.deck.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [this.state.deck[i], this.state.deck[j]] = [this.state.deck[j], this.state.deck[i]];
    }
  }
  
  /**
   * æŠ½ç‰Œ
   */
  private drawCards(count: number): void {
    for (let i = 0; i < count; i++) {
      if (this.state.hand.length >= 5) break;
      
      if (this.state.deck.length === 0) {
        // æ´—å¼ƒç‰Œå †
        this.state.deck = [...this.state.discardPile];
        this.state.discardPile = [];
        this.shuffleDeck();
      }
      
      if (this.state.deck.length > 0) {
        const card = this.state.deck.pop()!;
        this.state.hand.push(card);
      }
    }
  }
  
  /**
   * è·å–å½“å‰çŠ¶æ€ï¼ˆåªè¯»ï¼‰
   */
  getState(): Readonly<BattleState> {
    return this.state;
  }
}

/**
 * æˆ˜æ–—é…ç½®
 */
interface BattleConfig {
  mode: 'training' | 'exam';
  planType: 'sense' | 'logic' | 'anomaly';
  maxTurns?: number;
  initialStamina?: number;
  maxStamina?: number;
  stats: { vocal: number; dance: number; visual: number };
  targetScore?: number;
  perfectScore?: number;
  skillDeck: SkillCard[];
  support?: any;
}

/**
 * æˆ˜æ–—ç»“æœ
 */
interface BattleResult {
  mode: 'training' | 'exam';
  evaluation: 'perfect' | 'clear' | 'fail';
  finalScore: number;
  targetScore: number;
  perfectScore: number;
  turns: number;
  remainingStamina: number;
}
```

---

## 6. å®é™…ä½¿ç”¨ç¤ºä¾‹

### 6.1 åˆ›å»ºæˆ˜æ–—

```typescript
// 1. å‡†å¤‡æŠ€èƒ½å¡ç»„
const skillDeck: SkillCard[] = [
  // ä»æ•°æ®åº“åŠ è½½æˆ–AIç”Ÿæˆçš„æŠ€èƒ½å¡
  {
    id: 'card_001',
    name: 'æ·±å‘¼å¸',
    rarity: 'N',
    type: 'A',
    cost: -2,
    costType: 'normal',
    unique: false,
    enhanced: false,
    limitPerLesson: null,
    usedThisLesson: 0,
    effects: [
      { type: 'gain_genki', value: 10 },
      { type: 'recover_stamina', value: 5 }
    ],
    description: 'è·å¾—10å…ƒæ°”ï¼Œå›å¤5ä½“åŠ›'
  },
  // ... æ›´å¤šå¡ç‰Œ
];

// 2. åˆ›å»ºæˆ˜æ–—æ§åˆ¶å™¨
const battle = new BattleController({
  mode: 'training',
  planType: 'sense',
  maxTurns: 12,
  initialStamina: 60,
  maxStamina: 60,
  stats: { vocal: 300, dance: 250, visual: 200 },
  targetScore: 1000,
  perfectScore: 2000,
  skillDeck: skillDeck
});

// 3. å¼€å§‹æˆ˜æ–—
await battle.startBattle();

// 4. ä½¿ç”¨å¡ç‰Œ
const card = battle.getState().hand[0];
const result = await battle.useCard(card);

console.log(result.logs);  // æŸ¥çœ‹æ•ˆæœæ—¥å¿—

// 5. ç»“æŸå›åˆ
battle.skipAction();  // æˆ–ä½¿ç”¨å¡ç‰Œåè‡ªåŠ¨ç»“æŸ
```

### 6.2 è§£æçœŸå®æŠ€èƒ½å¡

```typescript
/**
 * å°†299å¼ çœŸå®æŠ€èƒ½å¡çš„æ–‡å­—æè¿°è½¬åŒ–ä¸ºSkillCardEffect[]
 */
class SkillCardParser {
  /**
   * è§£ææŠ€èƒ½å¡æ•ˆæœæ–‡æœ¬
   * 
   * ç¤ºä¾‹è¾“å…¥ï¼š
   * "æ¶ˆè€—ä½“åŠ›4ï¼Œæ•°å€¼+26ï¼ŒçŠ¶æ€è‰¯å¥½+1å›åˆï¼Œè¯¾ç¨‹ä¸­é™1æ¬¡"
   * 
   * è¾“å‡ºï¼š
   * [
   *   { type: 'consume_stamina', value: 4 },
   *   { type: 'add_score', value: 26 },
   *   { type: 'add_buff', metadata: { buffType: 'good_condition', duration: 1 } },
   * ]
   */
  static parseEffectText(text: string): SkillCardEffect[] {
    const effects: SkillCardEffect[] = [];
    
    // æ­£åˆ™åŒ¹é…å„ç§æ•ˆæœæ¨¡å¼
    const patterns = [
      // æ¶ˆè€—ä½“åŠ›
      { regex: /æ¶ˆè€—ä½“åŠ›(\d+)/, handler: (match: RegExpMatchArray) => ({
        type: 'consume_stamina' as EffectType,
        value: parseInt(match[1])
      })},
      
      // æ•°å€¼åŠ æˆ
      { regex: /æ•°å€¼\+(\d+)/, handler: (match: RegExpMatchArray) => ({
        type: 'add_score' as EffectType,
        value: parseInt(match[1])
      })},
      
      // Buffæ•ˆæœ
      { regex: /çŠ¶æ€è‰¯å¥½\+(\d+)å›åˆ/, handler: (match: RegExpMatchArray) => ({
        type: 'add_buff' as EffectType,
        metadata: { buffType: 'good_condition', duration: parseInt(match[1]) }
      })},
      
      { regex: /å¥½è°ƒ\+(\d+)å›åˆ/, handler: (match: RegExpMatchArray) => ({
        type: 'add_buff' as EffectType,
        metadata: { buffType: 'good_condition', duration: parseInt(match[1]) }
      })},
      
      { regex: /é›†ä¸­\+(\d+)/, handler: (match: RegExpMatchArray) => ({
        type: 'add_buff' as EffectType,
        metadata: { buffType: 'concentration', stacks: parseInt(match[1]) }
      })},
      
      { regex: /å¥½å°è±¡\+(\d+)/, handler: (match: RegExpMatchArray) => ({
        type: 'add_good_impression' as EffectType,
        value: parseInt(match[1])
      })},
      
      { regex: /å¹²åŠ²\+(\d+)/, handler: (match: RegExpMatchArray) => ({
        type: 'add_motivation' as EffectType,
        value: parseInt(match[1])
      })},
      
      // æŠ€èƒ½å¡ä½¿ç”¨æ•°
      { regex: /æŠ€èƒ½å¡ä½¿ç”¨æ•°\+(\d+)/, handler: (match: RegExpMatchArray) => ({
        type: 'add_card_uses' as EffectType,
        value: parseInt(match[1])
      })},
      
      // æŠ½ç‰Œ
      { regex: /æ‰‹ç‰Œ\+(\d+)/, handler: (match: RegExpMatchArray) => ({
        type: 'draw_cards' as EffectType,
        value: parseInt(match[1])
      })},
      
      // ... æ›´å¤šæ¨¡å¼
    ];
    
    for (const pattern of patterns) {
      const match = text.match(pattern.regex);
      if (match) {
        effects.push(pattern.handler(match));
      }
    }
    
    return effects;
  }
}

// ä½¿ç”¨ç¤ºä¾‹ï¼šæ‰¹é‡è½¬æ¢299å¼ å¡ç‰Œ
async function convertRealCardsToSkillCards() {
  const realCardsDb = await import('./å­¦å›­å¶åƒå¤§å¸ˆæŠ€èƒ½å¡æ•°æ®åº“.json');
  
  const convertedCards: SkillCard[] = [];
  
  for (const [attribute, rarities] of Object.entries(realCardsDb)) {
    for (const [rarity, cards] of Object.entries(rarities as any)) {
      for (const card of cards as any[]) {
        convertedCards.push({
          id: card.id,
          name: card.name,
          rarity: rarity as any,
          type: 'A',  // éœ€è¦æ‰‹åŠ¨æ ‡æ³¨
          cost: card.cost,
          costType: 'normal',
          unique: card.description.includes('ä¸å¯é‡å¤'),
          enhanced: false,
          limitPerLesson: this.parseLimitPerLesson(card.description),
          usedThisLesson: 0,
          effects: SkillCardParser.parseEffectText(card.effect_before),
          description: card.effect_before,
          imageUrl: `https://raw.githubusercontent.com/2426269/shinycolors-assets-cdn/main/æŠ€èƒ½å¡å¡é¢/${card.name.replace(/[\\/:"*?<>|]/g, '')}.webp`
        });
      }
    }
  }
  
  console.log(`è½¬æ¢å®Œæˆï¼š${convertedCards.length} å¼ æŠ€èƒ½å¡`);
  return convertedCards;
}
```

---

## 7. æ€»ç»“

### 7.1 æ ¸å¿ƒæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Vue UI å±‚                             â”‚
â”‚   CardGame.vue â†’ æ˜¾ç¤ºæ‰‹ç‰Œã€Buffã€çŠ¶æ€                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              BattleController                           â”‚
â”‚   æˆ˜æ–—æµç¨‹æ§åˆ¶ã€å›åˆç®¡ç†ã€èƒœè´Ÿåˆ¤å®š                       â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                    â”‚
â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚SkillCardExecutorâ”‚  â”‚  BuffManager   â”‚  â”‚AttributeManagerâ”‚
â”‚  æ•ˆæœæ‰§è¡Œå™¨    â”‚  â”‚  Buffç®¡ç†å™¨    â”‚  â”‚  å±æ€§ç®¡ç†å™¨   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                    â”‚                    â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚   BattleState    â”‚
                   â”‚  æˆ˜æ–—çŠ¶æ€æ•°æ®     â”‚
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 7.2 å…³é”®ç‚¹

1. **çŠ¶æ€é©±åŠ¨**: æ‰€æœ‰æ¸¸æˆé€»è¾‘éƒ½å›´ç»•`BattleState`å±•å¼€
2. **æ•ˆæœå¼•æ“**: å°†æ–‡å­—æè¿°çš„æ•ˆæœè½¬åŒ–ä¸º`SkillCardEffect[]`ï¼Œé€šè¿‡ç»Ÿä¸€çš„æ‰§è¡Œå™¨å¤„ç†
3. **Buffç³»ç»Ÿ**: ç‹¬ç«‹çš„Buffç®¡ç†å™¨ï¼Œæ”¯æŒè§¦å‘æ—¶æœºå’Œæ•ˆæœé“¾
4. **å±æ€§åˆ†ç¦»**: æ„Ÿæ€§/ç†æ€§/éå‡¡ä¸‰å¥—å±æ€§ç³»ç»Ÿï¼Œå„è‡ªç‹¬ç«‹ç®¡ç†
5. **å¯æ‰©å±•**: æ–°å¢æ•ˆæœç±»å‹åªéœ€åœ¨`EffectType`å’Œæ‰§è¡Œå™¨ä¸­æ·»åŠ case

### 7.3 ä¸‹ä¸€æ­¥

1. **å®ç°UIç»„ä»¶**ï¼ˆCardGame.vueï¼‰
2. **å®ŒæˆæŠ€èƒ½å¡è§£æå™¨**ï¼ˆå¤„ç†299å¼ çœŸå®å¡ç‰Œï¼‰
3. **å®ç°éå‡¡ç³»ç»Ÿ**ï¼ˆå››æ€åˆ‡æ¢ã€å…¨åŠ›å€¼è½¬åŒ–ï¼‰
4. **æ·»åŠ åŠ¨ç”»æ•ˆæœ**ï¼ˆGSAPï¼‰
5. **æµ‹è¯•ä¸å¹³è¡¡**ï¼ˆæ•°å€¼è°ƒæ•´ï¼‰

---

**æ–‡æ¡£çŠ¶æ€**: âœ… è®¾è®¡å®Œæˆ  
**ä¸‹ä¸€æ­¥**: å¼€å§‹å®ç°æ ¸å¿ƒç±»










