# æˆ˜æ–—ç³»ç»Ÿå®ç°æ–¹æ¡ˆ

**æ—¥æœŸ**: 2025-11-03
**ç‰ˆæœ¬**: v1.0.0

---

## ğŸ¯ æ ¸å¿ƒéš¾ç‚¹

**å¦‚ä½•å°†æŠ€èƒ½å¡çš„è‡ªç„¶è¯­è¨€æ•ˆæœæ–‡æœ¬è½¬åŒ–ä¸ºå®é™…çš„æ•°æ®å˜åŒ–ï¼Ÿ**

ä¾‹å¦‚ï¼š
- `"å…ƒæ°—+10"` â†’ å¢åŠ å…ƒæ°”å±æ€§10ç‚¹
- `"å¥½èª¿3ã‚¿ãƒ¼ãƒ³"` â†’ æ·»åŠ "å¥½è°ƒ"Buffï¼ŒæŒç»­3å›åˆ
- `"å¥½å°è±¡Ã—1.1"` â†’ å¥½å°è±¡æ•ˆæœå€ç‡Ã—1.1
- `"æ¶ˆè€—å¥½å°è±¡2ï¼Œä¸‹ä¸€å¼ å¡æ•ˆæœå‘åŠ¨2æ¬¡"` â†’ æ£€æŸ¥å¹¶æ‰£é™¤å¥½å°è±¡ï¼Œè®¾ç½®ä¸‹ä¸€å¼ å¡ç¿»å€æ ‡è®°

---

## ğŸ“ è®¾è®¡æ€è·¯

### æ–¹æ¡ˆé€‰æ‹©

æœ‰ä¸¤ç§ä¸»è¦æ–¹æ¡ˆï¼š

1. **AIå®æ—¶è§£ææ–¹æ¡ˆ**ï¼šæ¯æ¬¡ä½¿ç”¨æŠ€èƒ½å¡æ—¶ï¼Œè®©AIè§£ææ•ˆæœæ–‡æœ¬å¹¶ç”Ÿæˆæ‰§è¡ŒæŒ‡ä»¤
   - âŒ ä¼˜ç‚¹ï¼šçµæ´»ï¼Œæ”¯æŒä»»æ„è‡ªç„¶è¯­è¨€
   - âŒ ç¼ºç‚¹ï¼šé€Ÿåº¦æ…¢ï¼Œä¸ç¨³å®šï¼Œéš¾ä»¥è°ƒè¯•ï¼Œæˆæœ¬é«˜

2. **æ•ˆæœæ ‡è®°åŒ–+å¼•æ“æ‰§è¡Œæ–¹æ¡ˆ**ï¼ˆ**æ¨è**ï¼‰ï¼šå°†æ•ˆæœæ–‡æœ¬é¢„å¤„ç†ä¸ºç»“æ„åŒ–æ•°æ®ï¼Œç”±å¼•æ“æ‰§è¡Œ
   - âœ… ä¼˜ç‚¹ï¼šå¿«é€Ÿï¼Œç¨³å®šï¼Œå¯è°ƒè¯•ï¼Œæ˜“äºæµ‹è¯•
   - âœ… ç¼ºç‚¹ï¼šéœ€è¦é¢„å…ˆå®šä¹‰æ•ˆæœæ ¼å¼

**æˆ‘ä»¬é‡‡ç”¨æ–¹æ¡ˆ2**ï¼šæ•ˆæœæ ‡è®°åŒ–+å¼•æ“æ‰§è¡Œ

---

## ğŸ—ï¸ æ¶æ„è®¾è®¡

### æ ¸å¿ƒæ¨¡å—

```
æˆ˜æ–—ç³»ç»Ÿ/
â”œâ”€â”€ ç±»å‹/
â”‚   â”œâ”€â”€ æ•ˆæœç±»å‹.ts          # å®šä¹‰æ‰€æœ‰æ•ˆæœçš„ç±»å‹
â”‚   â”œâ”€â”€ æˆ˜æ–—çŠ¶æ€ç±»å‹.ts      # æˆ˜æ–—ä¸­çš„æ‰€æœ‰çŠ¶æ€
â”‚   â””â”€â”€ è®¡ç®—å™¨ç±»å‹.ts        # å¾—åˆ†è®¡ç®—ç›¸å…³
â”œâ”€â”€ æ•°æ®/
â”‚   â””â”€â”€ æ•ˆæœè§£æå™¨.ts        # å°†è‡ªç„¶è¯­è¨€è½¬ä¸ºç»“æ„åŒ–æ•ˆæœ
â”œâ”€â”€ æœåŠ¡/
â”‚   â”œâ”€â”€ æˆ˜æ–—çŠ¶æ€ç®¡ç†å™¨.ts    # ç»´æŠ¤æˆ˜æ–—çŠ¶æ€
â”‚   â”œâ”€â”€ æ•ˆæœæ‰§è¡Œå¼•æ“.ts      # æ‰§è¡Œæ•ˆæœ
â”‚   â”œâ”€â”€ å¾—åˆ†è®¡ç®—å™¨.ts        # è®¡ç®—æœ€ç»ˆå¾—åˆ†
â”‚   â”œâ”€â”€ Buffç®¡ç†å™¨.ts        # ç®¡ç†Buff/Debuff
â”‚   â””â”€â”€ å±æ€§ç®¡ç†å™¨.ts        # ç®¡ç†å…ƒæ°”ã€å¹²åŠ²ç­‰å±æ€§
â””â”€â”€ ç•Œé¢/
    â””â”€â”€ æˆ˜æ–—ç•Œé¢.vue         # Vueç»„ä»¶
```

---

## ğŸ”§ è¯¦ç»†å®ç°

### 1. æ•ˆæœç±»å‹å®šä¹‰

é¦–å…ˆå®šä¹‰æ‰€æœ‰å¯èƒ½çš„æ•ˆæœç±»å‹ï¼š

```typescript
// æ•ˆæœç±»å‹æšä¸¾
export enum EffectType {
  // å±æ€§æ“ä½œ
  ADD_ATTRIBUTE = 'ADD_ATTRIBUTE',           // å¢åŠ å±æ€§ï¼ˆå…ƒæ°”ã€å¹²åŠ²ç­‰ï¼‰
  CONSUME_ATTRIBUTE = 'CONSUME_ATTRIBUTE',   // æ¶ˆè€—å±æ€§
  
  // Buffæ“ä½œ
  ADD_BUFF = 'ADD_BUFF',                     // æ·»åŠ Buff
  REMOVE_BUFF = 'REMOVE_BUFF',               // ç§»é™¤Buff
  CONSUME_BUFF = 'CONSUME_BUFF',             // æ¶ˆè€—Buff
  
  // å¾—åˆ†æ“ä½œ
  ADD_SCORE = 'ADD_SCORE',                   // ç›´æ¥åŠ åˆ†
  MULTIPLY_SCORE = 'MULTIPLY_SCORE',         // å¾—åˆ†å€ç‡
  
  // ç‰¹æ®Šæ•ˆæœ
  DRAW_CARDS = 'DRAW_CARDS',                 // æŠ½å¡
  EXTRA_CARD_USE = 'EXTRA_CARD_USE',         // å¢åŠ å¡ç‰Œä½¿ç”¨æ¬¡æ•°
  NEXT_CARD_DOUBLE = 'NEXT_CARD_DOUBLE',     // ä¸‹ä¸€å¼ å¡æ•ˆæœç¿»å€
  ENHANCE_HAND = 'ENHANCE_HAND',             // å¼ºåŒ–æ‰‹ç‰Œ
  GENERATE_CARD = 'GENERATE_CARD',           // ç”Ÿæˆå¡ç‰Œ
  MOVE_CARD = 'MOVE_CARD',                   // ç§»åŠ¨å¡ç‰Œ
  
  // æ¡ä»¶æ•ˆæœ
  CONDITIONAL = 'CONDITIONAL',               // æ¡ä»¶è§¦å‘
  
  // çŠ¶æ€åˆ‡æ¢ï¼ˆéå‡¡ä¸“å±ï¼‰
  SWITCH_POINTER = 'SWITCH_POINTER',         // åˆ‡æ¢æŒ‡é’ˆçŠ¶æ€
  ADD_FULLPOWER = 'ADD_FULLPOWER',           // å¢åŠ å…¨åŠ›å€¼
}

// å±æ€§ç±»å‹
export enum AttributeType {
  ENERGY = 'ENERGY',         // å…ƒæ°”
  MOTIVATION = 'MOTIVATION', // å¹²åŠ²ï¼ˆã‚„ã‚‹æ°—ï¼‰
  FOCUS = 'FOCUS',           // ä¸“æ³¨
  CONCENTRATION = 'CONCENTRATION', // é›†ä¸­
  VITALITY = 'VITALITY',     // æ´»åŠ›
  FULLPOWER = 'FULLPOWER',   // å…¨åŠ›å€¼ï¼ˆéå‡¡ä¸“å±ï¼‰
  ENTHUSIASM = 'ENTHUSIASM', // çƒ­æ„ï¼ˆéå‡¡ä¸“å±ï¼‰
  STAMINA = 'STAMINA',       // ä½“åŠ›
}

// Buffç±»å‹
export enum BuffType {
  // æ„Ÿæ€§ç³»
  GOOD_CONDITION = 'GOOD_CONDITION',     // å¥½è°ƒ
  CONCENTRATION = 'CONCENTRATION',       // é›†ä¸­
  PERFECT_CONDITION = 'PERFECT_CONDITION', // ç»å¥½è°ƒ
  
  // ç†æ€§ç³»
  GOOD_IMPRESSION = 'GOOD_IMPRESSION',   // å¥½å°è±¡
  MOTIVATED = 'MOTIVATED',               // æœ‰å¹²åŠ²
  
  // é€šç”¨ç³»
  REDUCE_STAMINA_COST = 'REDUCE_STAMINA_COST',     // æ¶ˆè´¹ä½“åŠ›å‡å°‘
  REDUCE_STAMINA_COST_BY = 'REDUCE_STAMINA_COST_BY', // æ¶ˆè´¹ä½“åŠ›å‰Šå‡
  EXTRA_CARD_USE = 'EXTRA_CARD_USE',     // æŠ€èƒ½å¡ä½¿ç”¨æ•°è¿½åŠ 
  ENHANCED_IN_LESSON = 'ENHANCED_IN_LESSON', // è®­ç»ƒä¸­å¼ºåŒ–
  
  // è´Ÿé¢
  INCREASE_STAMINA_COST = 'INCREASE_STAMINA_COST', // æ¶ˆè´¹ä½“åŠ›å¢åŠ 
  NO_ENERGY_GAIN = 'NO_ENERGY_GAIN',     // å…ƒæ°”å¢åŠ æ— æ•ˆ
  BAD_CONDITION = 'BAD_CONDITION',       // ä¸è°ƒ
  SLUMP = 'SLUMP',                       // ä½è¿·
}

// æ•ˆæœæ•°æ®ç»“æ„
export interface Effect {
  type: EffectType;
  
  // é€šç”¨å‚æ•°
  value?: number;              // æ•°å€¼
  target?: AttributeType | BuffType; // ç›®æ ‡å±æ€§æˆ–Buff
  
  // æ¡ä»¶å‚æ•°
  condition?: {
    type: 'ATTRIBUTE_GTE' | 'ATTRIBUTE_LTE' | 'BUFF_EXISTS' | 'POINTER_STATE';
    target: AttributeType | BuffType | string;
    value: number | string;
  };
  
  // å­æ•ˆæœï¼ˆç”¨äºæ¡ä»¶æ•ˆæœï¼‰
  subEffects?: Effect[];
  
  // å…¶ä»–å‚æ•°
  duration?: number;           // æŒç»­å›åˆæ•°ï¼ˆç”¨äºBuffï¼‰
  rarity?: string;             // ç¨€æœ‰åº¦ï¼ˆç”¨äºç”Ÿæˆå¡ç‰Œï¼‰
  count?: number;              // æ•°é‡ï¼ˆç”¨äºæŠ½å¡ã€ç§»åŠ¨å¡ç­‰ï¼‰
  
  // æè¿°ï¼ˆç”¨äºæ—¥å¿—ï¼‰
  description?: string;
}

// æŠ€èƒ½å¡å®Œæ•´æ•°æ®
export interface SkillCardWithEffects extends SkillCard {
  parsedEffects: Effect[];     // è§£æåçš„æ•ˆæœåˆ—è¡¨
}
```

### 2. æ•ˆæœè§£æå™¨

å°†è‡ªç„¶è¯­è¨€æ•ˆæœæ–‡æœ¬è§£æä¸ºç»“æ„åŒ–çš„Effectæ•°ç»„ï¼š

```typescript
/**
 * æ•ˆæœè§£æå™¨
 * å°†æŠ€èƒ½å¡çš„è‡ªç„¶è¯­è¨€æ•ˆæœè½¬æ¢ä¸ºå¯æ‰§è¡Œçš„Effectå¯¹è±¡æ•°ç»„
 */
export class EffectParser {
  /**
   * è§£ææ•ˆæœæ–‡æœ¬
   * @param effectText åŸå§‹æ•ˆæœæ–‡æœ¬ï¼ˆå¦‚ "å…ƒæ°—+10"ï¼‰
   * @returns Effectå¯¹è±¡æ•°ç»„
   */
  static parse(effectText: string): Effect[] {
    const effects: Effect[] = [];
    
    // æŒ‰é¡¿å·æˆ–æ¢è¡Œåˆ†å‰²å¤šä¸ªæ•ˆæœ
    const parts = effectText.split(/[ã€\n]/);
    
    for (const part of parts) {
      const trimmed = part.trim();
      if (!trimmed) continue;
      
      // å±æ€§å¢åŠ ï¼šå…ƒæ°—+10
      if (/^(.+?)(\+|-)(\d+)$/.test(trimmed)) {
        effects.push(this.parseAttributeChange(trimmed));
      }
      // Buffæ·»åŠ ï¼šå¥½èª¿3ã‚¿ãƒ¼ãƒ³
      else if (/(.+?)(\d+)ã‚¿ãƒ¼ãƒ³/.test(trimmed)) {
        effects.push(this.parseBuffAdd(trimmed));
      }
      // æ¶ˆè€—å±æ€§ï¼šæ¶ˆè²»(.+?)(\d+)
      else if (/æ¶ˆè²»(.+?)(\d+)/.test(trimmed)) {
        effects.push(this.parseConsumeAttribute(trimmed));
      }
      // æ¡ä»¶æ•ˆæœï¼šè‹¥(.+?)â‰¥(\d+)å‰‡(.+)
      else if (/è‹¥|ã‚‚ã—/.test(trimmed)) {
        effects.push(this.parseConditional(trimmed));
      }
      // ç‰¹æ®Šæ•ˆæœ
      else {
        const special = this.parseSpecial(trimmed);
        if (special) effects.push(special);
      }
    }
    
    return effects;
  }
  
  /**
   * è§£æå±æ€§å˜åŒ–ï¼ˆå…ƒæ°—+10ã€å¹²åŠ²+4ï¼‰
   */
  private static parseAttributeChange(text: string): Effect {
    const match = text.match(/^(.+?)([+\-])(\d+)$/);
    if (!match) throw new Error(`æ— æ³•è§£æå±æ€§å˜åŒ–: ${text}`);
    
    const [, attrName, operator, valueStr] = match;
    const value = parseInt(valueStr) * (operator === '+' ? 1 : -1);
    const target = this.mapAttributeName(attrName);
    
    return {
      type: value > 0 ? EffectType.ADD_ATTRIBUTE : EffectType.CONSUME_ATTRIBUTE,
      target,
      value: Math.abs(value),
      description: text,
    };
  }
  
  /**
   * è§£æBuffæ·»åŠ ï¼ˆå¥½èª¿3ã‚¿ãƒ¼ãƒ³ã€é›†ä¸­+2ï¼‰
   */
  private static parseBuffAdd(text: string): Effect {
    // å¥½èª¿3ã‚¿ãƒ¼ãƒ³
    const match1 = text.match(/(.+?)(\d+)ã‚¿ãƒ¼ãƒ³/);
    if (match1) {
      const [, buffName, durationStr] = match1;
      const target = this.mapBuffName(buffName);
      const duration = parseInt(durationStr);
      
      return {
        type: EffectType.ADD_BUFF,
        target,
        value: 1, // å±‚æ•°é»˜è®¤ä¸º1
        duration,
        description: text,
      };
    }
    
    // é›†ä¸­+2
    const match2 = text.match(/(.+?)\+(\d+)/);
    if (match2) {
      const [, buffName, valueStr] = match2;
      const target = this.mapBuffName(buffName);
      const value = parseInt(valueStr);
      
      return {
        type: EffectType.ADD_BUFF,
        target,
        value,
        description: text,
      };
    }
    
    throw new Error(`æ— æ³•è§£æBuffæ·»åŠ : ${text}`);
  }
  
  /**
   * è§£ææ¶ˆè€—å±æ€§ï¼ˆæ¶ˆè²»å¹²åŠ²3ã€æ¶ˆè²»å¥½å°è±¡2ï¼‰
   */
  private static parseConsumeAttribute(text: string): Effect {
    const match = text.match(/æ¶ˆè²»(.+?)(\d+)/);
    if (!match) throw new Error(`æ— æ³•è§£ææ¶ˆè€—: ${text}`);
    
    const [, attrName, valueStr] = match;
    const target = this.mapAttributeName(attrName);
    const value = parseInt(valueStr);
    
    return {
      type: EffectType.CONSUME_ATTRIBUTE,
      target,
      value,
      description: text,
    };
  }
  
  /**
   * è§£ææ¡ä»¶æ•ˆæœï¼ˆè‹¥å¥½å°è±¡â‰¥3å‰‡å¹²åŠ²+2ï¼‰
   */
  private static parseConditional(text: string): Effect {
    // ç®€åŒ–ç‰ˆï¼Œå®é™…éœ€è¦æ›´å¤æ‚çš„è§£æ
    const match = text.match(/è‹¥(.+?)([â‰¥â‰¤>=<])(\d+)å‰‡(.+)/);
    if (!match) throw new Error(`æ— æ³•è§£ææ¡ä»¶: ${text}`);
    
    const [, condTarget, operator, condValue, thenEffect] = match;
    const target = this.mapAttributeName(condTarget) || this.mapBuffName(condTarget);
    
    return {
      type: EffectType.CONDITIONAL,
      condition: {
        type: operator.includes('â‰¥') || operator.includes('>=') ? 'ATTRIBUTE_GTE' : 'ATTRIBUTE_LTE',
        target,
        value: parseInt(condValue),
      },
      subEffects: this.parse(thenEffect),
      description: text,
    };
  }
  
  /**
   * è§£æç‰¹æ®Šæ•ˆæœ
   */
  private static parseSpecial(text: string): Effect | null {
    // æŠ€èƒ½å¡ä½¿ç”¨æ•°+1
    if (text.includes('ã‚¹ã‚­ãƒ«ã‚«ãƒ¼ãƒ‰ä½¿ç”¨æ•°') || text.includes('æŠ€èƒ½å¡ä½¿ç”¨æ•°')) {
      const match = text.match(/(\d+)/);
      const value = match ? parseInt(match[1]) : 1;
      return {
        type: EffectType.EXTRA_CARD_USE,
        value,
        description: text,
      };
    }
    
    // ä¸‹ä¸€å¼ å¡æ•ˆæœå‘åŠ¨2æ¬¡
    if (text.includes('ä¸‹ä¸€å¼µå¡') || text.includes('æ¬¡ã®ã‚«ãƒ¼ãƒ‰')) {
      return {
        type: EffectType.NEXT_CARD_DOUBLE,
        value: 2,
        description: text,
      };
    }
    
    // å¾—åˆ†+X
    if (/ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿\+(\d+)/.test(text) || /å¾—åˆ†\+(\d+)/.test(text)) {
      const match = text.match(/(\d+)/);
      const value = match ? parseInt(match[1]) : 0;
      return {
        type: EffectType.ADD_SCORE,
        value,
        description: text,
      };
    }
    
    // æ›´å¤šç‰¹æ®Šæ•ˆæœ...
    
    return null;
  }
  
  /**
   * æ˜ å°„å±æ€§åç§°åˆ°æšä¸¾
   */
  private static mapAttributeName(name: string): AttributeType {
    const map: Record<string, AttributeType> = {
      'å…ƒæ°—': AttributeType.ENERGY,
      'å…ƒæ°”': AttributeType.ENERGY,
      'å¹²åŠ²': AttributeType.MOTIVATION,
      'ã‚„ã‚‹æ°—': AttributeType.MOTIVATION,
      'ä¸“æ³¨': AttributeType.FOCUS,
      'å°‚æ³¨': AttributeType.FOCUS,
      'é›†ä¸­': AttributeType.CONCENTRATION,
      'æ´»åŠ›': AttributeType.VITALITY,
      'å…¨åŠ›å€¤': AttributeType.FULLPOWER,
      'å…¨åŠ›å€¼': AttributeType.FULLPOWER,
      'çƒ­æ„': AttributeType.ENTHUSIASM,
      'ç†±æ„': AttributeType.ENTHUSIASM,
      'ä½“åŠ›': AttributeType.STAMINA,
    };
    return map[name] || AttributeType.ENERGY;
  }
  
  /**
   * æ˜ å°„Buffåç§°åˆ°æšä¸¾
   */
  private static mapBuffName(name: string): BuffType {
    const map: Record<string, BuffType> = {
      'å¥½èª¿': BuffType.GOOD_CONDITION,
      'å¥½è°ƒ': BuffType.GOOD_CONDITION,
      'é›†ä¸­': BuffType.CONCENTRATION,
      'çµ¶å¥½èª¿': BuffType.PERFECT_CONDITION,
      'ç»å¥½è°ƒ': BuffType.PERFECT_CONDITION,
      'å¥½å°è±¡': BuffType.GOOD_IMPRESSION,
      'æœ‰å¹²åŠ²': BuffType.MOTIVATED,
      'ã‚„ã‚‹æ°—': BuffType.MOTIVATED,
      'æ¶ˆè²»ä½“åŠ›æ¸›å°‘': BuffType.REDUCE_STAMINA_COST,
      'æ¶ˆè´¹ä½“åŠ›å‡å°‘': BuffType.REDUCE_STAMINA_COST,
    };
    return map[name] || BuffType.GOOD_CONDITION;
  }
}
```

### 3. æˆ˜æ–—çŠ¶æ€ç®¡ç†å™¨

ç»´æŠ¤æˆ˜æ–—ä¸­çš„æ‰€æœ‰çŠ¶æ€ï¼š

```typescript
/**
 * æˆ˜æ–—çŠ¶æ€
 */
export interface BattleState {
  // åŸºç¡€å±æ€§
  attributes: {
    [AttributeType.ENERGY]: number;
    [AttributeType.MOTIVATION]: number;
    [AttributeType.FOCUS]: number;
    [AttributeType.CONCENTRATION]: number;
    [AttributeType.VITALITY]: number;
    [AttributeType.FULLPOWER]: number;
    [AttributeType.ENTHUSIASM]: number;
    [AttributeType.STAMINA]: number;
  };
  
  // Buff/Debuff
  buffs: Map<BuffType, { value: number; duration?: number }>;
  
  // å¾—åˆ†
  currentScore: number;
  scoreMultipliers: number[];  // å¾—åˆ†å€ç‡æ ˆ
  
  // å¡ç‰Œ
  deck: SkillCard[];           // ç‰Œç»„
  hand: SkillCard[];           // æ‰‹ç‰Œ
  discardPile: SkillCard[];    // å¼ƒç‰Œå †
  excludePile: SkillCard[];    // é™¤å¤–å †
  
  // å›åˆä¿¡æ¯
  currentTurn: number;
  maxTurns: number;
  cardsUsedThisTurn: number;
  maxCardsPerTurn: number;
  
  // ç‰¹æ®Šæ ‡è®°
  nextCardDouble: boolean;     // ä¸‹ä¸€å¼ å¡æ•ˆæœç¿»å€
  currentTheme: 'Vocal' | 'Dance' | 'Visual'; // å½“å‰ä¸»é¢˜ï¼ˆæ¯”èµ›ç”¨ï¼‰
  
  // åŸ¹è‚²è®¡åˆ’
  plan: ProducePlan;
  
  // éå‡¡ä¸“å±
  pointerState?: 'FULLPOWER' | 'DECISIVE' | 'CONSERVATIVE';
  pointerPhase?: 1 | 2;        // åšå†³/æ¸©å­˜çš„é˜¶æ®µ
}

/**
 * æˆ˜æ–—çŠ¶æ€ç®¡ç†å™¨
 */
export class BattleStateManager {
  private state: BattleState;
  
  constructor(initialState: Partial<BattleState>) {
    this.state = this.initializeState(initialState);
  }
  
  /**
   * åˆå§‹åŒ–çŠ¶æ€
   */
  private initializeState(initial: Partial<BattleState>): BattleState {
    return {
      attributes: {
        [AttributeType.ENERGY]: 0,
        [AttributeType.MOTIVATION]: 0,
        [AttributeType.FOCUS]: 0,
        [AttributeType.CONCENTRATION]: 0,
        [AttributeType.VITALITY]: 0,
        [AttributeType.FULLPOWER]: 0,
        [AttributeType.ENTHUSIASM]: 0,
        [AttributeType.STAMINA]: initial.attributes?.[AttributeType.STAMINA] || 50,
      },
      buffs: new Map(),
      currentScore: 0,
      scoreMultipliers: [1],
      deck: initial.deck || [],
      hand: [],
      discardPile: [],
      excludePile: [],
      currentTurn: 1,
      maxTurns: initial.maxTurns || 12,
      cardsUsedThisTurn: 0,
      maxCardsPerTurn: 1,
      nextCardDouble: false,
      currentTheme: 'Vocal',
      plan: initial.plan || 'æ„Ÿæ€§',
      ...initial,
    };
  }
  
  /**
   * è·å–å½“å‰çŠ¶æ€ï¼ˆåªè¯»ï¼‰
   */
  getState(): Readonly<BattleState> {
    return { ...this.state };
  }
  
  /**
   * ä¿®æ”¹å±æ€§
   */
  modifyAttribute(type: AttributeType, delta: number): void {
    this.state.attributes[type] = Math.max(0, this.state.attributes[type] + delta);
    console.log(`${type}: ${this.state.attributes[type] - delta} â†’ ${this.state.attributes[type]}`);
  }
  
  /**
   * æ·»åŠ Buff
   */
  addBuff(type: BuffType, value: number, duration?: number): void {
    const existing = this.state.buffs.get(type);
    if (existing) {
      // ç´¯åŠ å±‚æ•°æˆ–å»¶é•¿æ—¶é—´
      this.state.buffs.set(type, {
        value: existing.value + value,
        duration: duration !== undefined ? Math.max(existing.duration || 0, duration) : existing.duration,
      });
    } else {
      this.state.buffs.set(type, { value, duration });
    }
    console.log(`æ·»åŠ Buff: ${type} +${value}å±‚${duration ? ` (${duration}å›åˆ)` : ''}`);
  }
  
  /**
   * ç§»é™¤/å‡å°‘Buff
   */
  removeBuff(type: BuffType, value: number = 1): boolean {
    const existing = this.state.buffs.get(type);
    if (!existing) return false;
    
    const newValue = existing.value - value;
    if (newValue <= 0) {
      this.state.buffs.delete(type);
      console.log(`ç§»é™¤Buff: ${type}`);
    } else {
      this.state.buffs.set(type, { ...existing, value: newValue });
      console.log(`å‡å°‘Buff: ${type} -${value}å±‚ (å‰©ä½™${newValue}å±‚)`);
    }
    return true;
  }
  
  /**
   * å›åˆç»“æŸå¤„ç†
   */
  endTurn(): void {
    // Buffå›åˆæ•°é€’å‡
    for (const [type, buff] of this.state.buffs) {
      if (buff.duration !== undefined) {
        buff.duration--;
        if (buff.duration <= 0) {
          this.state.buffs.delete(type);
          console.log(`Buff ${type} æŒç»­æ—¶é—´ç»“æŸ`);
        }
      }
    }
    
    // é‡ç½®å›åˆçŠ¶æ€
    this.state.currentTurn++;
    this.state.cardsUsedThisTurn = 0;
    this.state.nextCardDouble = false;
    
    // æŠ½å¡
    this.drawCards(3);
  }
  
  /**
   * æŠ½å¡
   */
  drawCards(count: number): void {
    for (let i = 0; i < count && this.state.hand.length < 5; i++) {
      if (this.state.deck.length === 0) {
        // é‡ç»„ç‰Œç»„
        this.state.deck = [...this.state.discardPile];
        this.state.discardPile = [];
        this.shuffleDeck();
      }
      
      if (this.state.deck.length > 0) {
        const card = this.state.deck.pop()!;
        this.state.hand.push(card);
      }
    }
  }
  
  /**
   * æ´—ç‰Œ
   */
  private shuffleDeck(): void {
    for (let i = this.state.deck.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [this.state.deck[i], this.state.deck[j]] = [this.state.deck[j], this.state.deck[i]];
    }
  }
  
  /**
   * ä½¿ç”¨å¡ç‰Œ
   */
  useCard(cardIndex: number): void {
    const card = this.state.hand[cardIndex];
    if (!card) return;
    
    this.state.hand.splice(cardIndex, 1);
    this.state.discardPile.push(card);
    this.state.cardsUsedThisTurn++;
  }
  
  // æ›´å¤šæ–¹æ³•...
}
```

### 4. æ•ˆæœæ‰§è¡Œå¼•æ“

æ‰§è¡Œè§£æåçš„Effectï¼š

```typescript
/**
 * æ•ˆæœæ‰§è¡Œå¼•æ“
 */
export class EffectEngine {
  private stateManager: BattleStateManager;
  
  constructor(stateManager: BattleStateManager) {
    this.stateManager = stateManager;
  }
  
  /**
   * æ‰§è¡Œæ•ˆæœåˆ—è¡¨
   */
  executeEffects(effects: Effect[], doubleEffect: boolean = false): void {
    const multiplier = doubleEffect ? 2 : 1;
    
    for (const effect of effects) {
      this.executeEffect(effect, multiplier);
    }
  }
  
  /**
   * æ‰§è¡Œå•ä¸ªæ•ˆæœ
   */
  private executeEffect(effect: Effect, multiplier: number = 1): void {
    console.log(`æ‰§è¡Œæ•ˆæœ: ${effect.description}`);
    
    switch (effect.type) {
      case EffectType.ADD_ATTRIBUTE:
        this.stateManager.modifyAttribute(
          effect.target as AttributeType,
          (effect.value || 0) * multiplier,
        );
        break;
      
      case EffectType.CONSUME_ATTRIBUTE:
        this.stateManager.modifyAttribute(
          effect.target as AttributeType,
          -(effect.value || 0),
        );
        break;
      
      case EffectType.ADD_BUFF:
        this.stateManager.addBuff(
          effect.target as BuffType,
          (effect.value || 1) * multiplier,
          effect.duration,
        );
        break;
      
      case EffectType.CONSUME_BUFF:
        this.stateManager.removeBuff(
          effect.target as BuffType,
          effect.value || 1,
        );
        break;
      
      case EffectType.ADD_SCORE:
        // å¾—åˆ†éœ€è¦ç»è¿‡è®¡ç®—å™¨å¤„ç†
        this.addScore((effect.value || 0) * multiplier);
        break;
      
      case EffectType.EXTRA_CARD_USE:
        const state = this.stateManager.getState();
        this.stateManager.addBuff(
          BuffType.EXTRA_CARD_USE,
          (effect.value || 1) * multiplier,
        );
        break;
      
      case EffectType.NEXT_CARD_DOUBLE:
        // è®¾ç½®æ ‡è®°
        (this.stateManager as any).state.nextCardDouble = true;
        break;
      
      case EffectType.CONDITIONAL:
        if (this.checkCondition(effect.condition!)) {
          effect.subEffects?.forEach(e => this.executeEffect(e, multiplier));
        }
        break;
      
      // æ›´å¤šæ•ˆæœç±»å‹...
    }
  }
  
  /**
   * æ£€æŸ¥æ¡ä»¶
   */
  private checkCondition(condition: Effect['condition']): boolean {
    if (!condition) return false;
    
    const state = this.stateManager.getState();
    
    switch (condition.type) {
      case 'ATTRIBUTE_GTE':
        const attrValue = state.attributes[condition.target as AttributeType];
        return attrValue >= (condition.value as number);
      
      case 'BUFF_EXISTS':
        return state.buffs.has(condition.target as BuffType);
      
      // æ›´å¤šæ¡ä»¶ç±»å‹...
      
      default:
        return false;
    }
  }
  
  /**
   * æ·»åŠ å¾—åˆ†ï¼ˆç»è¿‡BuffåŠ æˆè®¡ç®—ï¼‰
   */
  private addScore(baseScore: number): void {
    // è¿™é‡Œä¼šè°ƒç”¨å¾—åˆ†è®¡ç®—å™¨
    const finalScore = ScoreCalculator.calculate(baseScore, this.stateManager.getState());
    (this.stateManager as any).state.currentScore += finalScore;
    console.log(`å¾—åˆ†: ${baseScore} â†’ ${finalScore} (æ€»åˆ†: ${(this.stateManager as any).state.currentScore})`);
  }
}
```

### 5. å¾—åˆ†è®¡ç®—å™¨

è®¡ç®—æœ€ç»ˆå¾—åˆ†ï¼ˆåº”ç”¨å„ç§Buffå’Œå€ç‡ï¼‰ï¼š

```typescript
/**
 * å¾—åˆ†è®¡ç®—å™¨
 */
export class ScoreCalculator {
  /**
   * è®¡ç®—æœ€ç»ˆå¾—åˆ†
   * @param baseScore åŸºç¡€å¾—åˆ†
   * @param state æˆ˜æ–—çŠ¶æ€
   * @returns æœ€ç»ˆå¾—åˆ†
   */
  static calculate(baseScore: number, state: Readonly<BattleState>): number {
    let score = baseScore;
    
    // 1. åº”ç”¨"å¥½è°ƒ"ï¼ˆæ„Ÿæ€§ï¼‰
    if (state.buffs.has(BuffType.GOOD_CONDITION)) {
      score *= 1.5; // +50%
      console.log(`  [å¥½è°ƒ] ${score / 1.5} â†’ ${score}`);
    }
    
    // 2. åº”ç”¨"ç»å¥½è°ƒ"ï¼ˆæ„Ÿæ€§ï¼‰
    if (state.buffs.has(BuffType.PERFECT_CONDITION)) {
      const layers = state.buffs.get(BuffType.PERFECT_CONDITION)!.value;
      const bonus = 1 + (layers * 0.1); // æ¯å±‚+10%
      score *= bonus;
      console.log(`  [ç»å¥½è°ƒÃ—${layers}] ${score / bonus} â†’ ${score}`);
    }
    
    // 3. åº”ç”¨"é›†ä¸­"ï¼ˆæ„Ÿæ€§ï¼‰
    if (state.buffs.has(BuffType.CONCENTRATION)) {
      const layers = state.buffs.get(BuffType.CONCENTRATION)!.value;
      score += layers; // æ¯å±‚+1åˆ†
      console.log(`  [é›†ä¸­Ã—${layers}] +${layers}`);
    }
    
    // 4. åº”ç”¨"ä¸è°ƒ"ï¼ˆè´Ÿé¢ï¼‰
    if (state.buffs.has(BuffType.BAD_CONDITION)) {
      score *= 0.67; // -33%
      console.log(`  [ä¸è°ƒ] ${score / 0.67} â†’ ${score}`);
    }
    
    // 5. åº”ç”¨"ä½è¿·"ï¼ˆè´Ÿé¢ï¼‰
    if (state.buffs.has(BuffType.SLUMP)) {
      score = 0;
      console.log(`  [ä½è¿·] å¾—åˆ†å½’é›¶`);
    }
    
    // 6. åº”ç”¨ä¸‰ç»´åŠ æˆï¼ˆæ¯”èµ›æ—¶ï¼‰
    // const threeValueBonus = this.getThreeValueBonus(state);
    // score *= threeValueBonus;
    
    return Math.floor(score);
  }
  
  /**
   * è·å–ä¸‰ç»´åŠ æˆå€ç‡ï¼ˆæ¯”èµ›ä¸“ç”¨ï¼‰
   */
  private static getThreeValueBonus(state: Readonly<BattleState>): number {
    // æ ¹æ®å½“å‰ä¸»é¢˜å’Œä¸‰ç»´å€¼è®¡ç®—
    // è¿™é‡Œéœ€è¦è®¿é—®å¶åƒçš„ä¸‰ç»´å±æ€§
    // ä¾‹å¦‚ï¼šVocal=1000 â†’ åœ¨Vocalå›åˆä¸­ï¼Œå¾—åˆ†Ã—2.5
    return 1;
  }
}
```

---

## ğŸ® ä½¿ç”¨ç¤ºä¾‹

### å®Œæ•´çš„æŠ€èƒ½å¡ä½¿ç”¨æµç¨‹

```typescript
// 1. åˆå§‹åŒ–æˆ˜æ–—
const stateManager = new BattleStateManager({
  plan: 'æ„Ÿæ€§',
  deck: [...initialDeck],
  maxTurns: 12,
  attributes: {
    [AttributeType.STAMINA]: 50,
  },
});

const effectEngine = new EffectEngine(stateManager);

// 2. å¼€å±€æŠ½å¡
stateManager.drawCards(3);

// 3. ç©å®¶é€‰æ‹©ä½¿ç”¨ç¬¬ä¸€å¼ æ‰‹ç‰Œ
const card = stateManager.getState().hand[0] as SkillCardWithEffects;

// 4. è§£ææŠ€èƒ½å¡æ•ˆæœï¼ˆå·²é¢„å¤„ç†ï¼‰
if (!card.parsedEffects) {
  card.parsedEffects = EffectParser.parse(card.effect_before);
}

// 5. æ£€æŸ¥æ˜¯å¦å¯ä»¥ä½¿ç”¨
const canUse = canUseSkillCard(card, stateManager.getState());
if (!canUse) {
  console.log('èµ„æºä¸è¶³ï¼Œæ— æ³•ä½¿ç”¨');
  return;
}

// 6. æ‰£é™¤æˆæœ¬
const cost = parseCost(card.cost);
if (cost > 0) {
  // ä¼˜å…ˆæ¶ˆè€—å…ƒæ°”
  const energy = stateManager.getState().attributes[AttributeType.ENERGY];
  if (energy >= cost) {
    stateManager.modifyAttribute(AttributeType.ENERGY, -cost);
  } else {
    stateManager.modifyAttribute(AttributeType.ENERGY, -energy);
    stateManager.modifyAttribute(AttributeType.STAMINA, -(cost - energy));
  }
}

// 7. æ‰§è¡Œæ•ˆæœ
const doubleEffect = stateManager.getState().nextCardDouble;
effectEngine.executeEffects(card.parsedEffects, doubleEffect);

// 8. å°†å¡ç‰Œç§»è‡³å¼ƒç‰Œå †
stateManager.useCard(0);

// 9. å›åˆç»“æŸ
if (stateManager.getState().cardsUsedThisTurn >= stateManager.getState().maxCardsPerTurn) {
  stateManager.endTurn();
}

// 10. æŸ¥çœ‹æœ€ç»ˆå¾—åˆ†
console.log(`å½“å‰å¾—åˆ†: ${stateManager.getState().currentScore}`);
```

---

## ğŸ“ é¢„å¤„ç†æŠ€èƒ½å¡æ•°æ®

åœ¨æ¸¸æˆåŠ è½½æ—¶ï¼Œé¢„å¤„ç†æ‰€æœ‰æŠ€èƒ½å¡ï¼š

```typescript
/**
 * é¢„å¤„ç†æŠ€èƒ½å¡åº“
 */
export function preprocessSkillCards(): SkillCardWithEffects[] {
  const allCards = getAllSkillCards();
  
  return allCards.map(card => ({
    ...card,
    parsedEffects: EffectParser.parse(card.effect_before),
  }));
}

// æ¸¸æˆå¯åŠ¨æ—¶æ‰§è¡Œ
const PROCESSED_SKILL_CARDS = preprocessSkillCards();
console.log(`å·²é¢„å¤„ç† ${PROCESSED_SKILL_CARDS.length} å¼ æŠ€èƒ½å¡`);
```

---

## âœ… ä¼˜åŠ¿

1. **æ€§èƒ½ä¼˜å¼‚**ï¼šé¢„å¤„ç†åï¼Œæ¯æ¬¡ä½¿ç”¨æŠ€èƒ½å¡åªéœ€æ‰§è¡Œæ•ˆæœï¼Œæ— éœ€é‡æ–°è§£æ
2. **æ˜“äºè°ƒè¯•**ï¼šå¯ä»¥æ‰“å°Effectå¯¹è±¡ï¼Œæ¸…æ™°äº†è§£æ¯ä¸ªæ•ˆæœçš„æ‰§è¡Œæƒ…å†µ
3. **å¯æ‰©å±•æ€§å¼º**ï¼šæ–°å¢æ•ˆæœç±»å‹åªéœ€æ·»åŠ æšä¸¾å’Œæ‰§è¡Œé€»è¾‘
4. **ç±»å‹å®‰å…¨**ï¼šTypeScriptç¡®ä¿ç±»å‹æ­£ç¡®
5. **æ˜“äºæµ‹è¯•**ï¼šæ¯ä¸ªæ¨¡å—ç‹¬ç«‹ï¼Œå¯å•ç‹¬æµ‹è¯•

---

## ğŸ”® ä¸‹ä¸€æ­¥

1. **å®ç°å®Œæ•´çš„EffectParser**ï¼šè¦†ç›–æ‰€æœ‰298å¼ æŠ€èƒ½å¡çš„æ•ˆæœæ¨¡å¼
2. **å®ç°Buffç®¡ç†å™¨**ï¼šä¸“é—¨ç®¡ç†Buffçš„å±‚æ•°ã€æŒç»­æ—¶é—´ã€è§¦å‘æ¡ä»¶
3. **å®ç°å¾—åˆ†è®¡ç®—å™¨**ï¼šå®Œæ•´çš„å¾—åˆ†è®¡ç®—é€»è¾‘ï¼ŒåŒ…æ‹¬ä¸‰ç»´åŠ æˆ
4. **å®ç°æˆ˜æ–—UI**ï¼šVueç»„ä»¶ï¼Œå±•ç¤ºæˆ˜æ–—çŠ¶æ€å’Œå¡ç‰Œ
5. **ç¼–å†™æµ‹è¯•**ï¼šä¸ºæ¯ä¸ªæ¨¡å—ç¼–å†™å•å…ƒæµ‹è¯•
6. **æ€§èƒ½ä¼˜åŒ–**ï¼šç¡®ä¿æµç•…çš„æ¸¸æˆä½“éªŒ

---

**æœ€åæ›´æ–°**: 2025-11-03
**ç‰ˆæœ¬**: v1.0.0


